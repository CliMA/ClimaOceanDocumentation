var documenterSearchIndex = {"docs":
[{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"EditURL = \"../../../examples/near_global_ocean_simulation.jl\"","category":"page"},{"location":"literated/near_global_ocean_simulation/#Near-global-ocean-simulation","page":"Near-global Ocean simulation","title":"Near-global ocean simulation","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"This example sets up and runs a near-global ocean simulation using the Oceananigans.jl and ClimaOcean.jl. The simulation covers latitudes from 75°S to 75°N with a horizontal resolution of 1/4 degree and 40 vertical levels.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"The simulation's results are visualized using the CairoMakie.jl package.","category":"page"},{"location":"literated/near_global_ocean_simulation/#Initial-setup-with-package-imports","page":"Near-global Ocean simulation","title":"Initial setup with package imports","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We begin by importing the necessary Julia packages for visualization (CairoMakie), ocean modeling (Oceananigans, ClimaOcean), and handling dates and times (CFTime, Dates). These packages provide the foundational tools for setting up the simulation environment, including grid setup, physical processes modeling, and data visualization.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"using Printf\nusing Oceananigans\nusing Oceananigans.Units\nusing ClimaOcean\nusing CairoMakie\n\nusing CFTime\nusing Dates","category":"page"},{"location":"literated/near_global_ocean_simulation/#Grid-configuration","page":"Near-global Ocean simulation","title":"Grid configuration","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We define a global grid with a horizontal resolution of 1/4 degree and 40 vertical levels. The grid is a LatitudeLongitudeGrid spanning latitudes from 75°S to 75°N. We use an exponential vertical spacing to better resolve the upper ocean layers. The total depth of the domain is set to 6000 meters. Finally, we specify the architecture for the simulation, which in this case is a GPU.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"arch = GPU()\n\nNx = 1440\nNy = 600\nNz = 40\n\ndepth = 6000meters\nz_faces = exponential_z_faces(; Nz, depth)\n\ngrid = LatitudeLongitudeGrid(arch;\n                             size = (Nx, Ny, Nz),\n                             halo = (7, 7, 7),\n                             z = z_faces,\n                             latitude  = (-75, 75),\n                             longitude = (0, 360))","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"1440×600×40 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.GPU with 7×7×7 halo and with precomputed metrics\n├── longitude: Periodic λ ∈ [0.0, 360.0)   regularly spaced with Δλ=0.25\n├── latitude:  Bounded  φ ∈ [-75.0, 75.0]  regularly spaced with Δφ=0.25\n└── z:         Bounded  z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=8.0258, max(Δz)=645.588","category":"page"},{"location":"literated/near_global_ocean_simulation/#Bathymetry-and-immersed-boundary","page":"Near-global Ocean simulation","title":"Bathymetry and immersed boundary","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We use regrid_bathymetry to derive the bottom height from ETOPO1 data. To smooth the interpolated data we use 5 interpolation passes. We also fill in all the minor enclosed basins except the 3 largest major_basins, as well as regions that are shallower than minimum_depth.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"bottom_height = regrid_bathymetry(grid;\n                                  minimum_depth = 10meters,\n                                  interpolation_passes = 5,\n                                  major_basins = 3)\n\ngrid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom_height))","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"1440×600×40 ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.GPU with 7×7×7 halo:\n├── immersed_boundary: GridFittedBottom(mean(z)=-2513.5, min(z)=-6000.0, max(z)=0.0)\n├── underlying_grid: 1440×600×40 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.GPU with 7×7×7 halo and with precomputed metrics\n├── longitude: Periodic λ ∈ [0.0, 360.0)   regularly spaced with Δλ=0.25\n├── latitude:  Bounded  φ ∈ [-75.0, 75.0]  regularly spaced with Δφ=0.25\n└── z:         Bounded  z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=8.0258, max(Δz)=645.588","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Let's see what the bathymetry looks like:","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"h = grid.immersed_boundary.bottom_height\n\nfig, ax, hm = heatmap(h, colormap=:deep, colorrange=(-depth, 0))\ncb = Colorbar(fig[0, 1], hm, label=\"Bottom height (m)\", vertical=false)\nhidedecorations!(ax)\nsave(\"bathymetry.png\", fig)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"(Image: )","category":"page"},{"location":"literated/near_global_ocean_simulation/#Ocean-model-configuration","page":"Near-global Ocean simulation","title":"Ocean model configuration","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We build our ocean model using ocean_simulation,","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"ocean = ocean_simulation(grid)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Simulation of HydrostaticFreeSurfaceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 5 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: Inf days\n├── Stop iteration: Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"which uses the default ocean.model,","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"ocean.model","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"HydrostaticFreeSurfaceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── grid: 1440×600×40 ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.GPU with 7×7×7 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: (T, S, e)\n├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}\n├── buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with ĝ = NegativeZDirection()\n├── free surface: Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²\n│   └── substepping: FixedTimeStepSize(20.254 seconds)\n├── advection scheme: \n│   ├── momentum: Vector Invariant, Dimension-by-dimension reconstruction\n│   ├── T: FluxFormAdvection(x=WENO(order=7), y=WENO(order=7), z=Centered(order=2))\n│   ├── S: FluxFormAdvection(x=WENO(order=7), y=WENO(order=7), z=Centered(order=2))\n│   └── e: Nothing\n└── coriolis: Oceananigans.Coriolis.HydrostaticSphericalCoriolis{Oceananigans.Coriolis.ActiveCellEnstrophyConserving, Float64}","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We initialize the ocean model to ECCO2 temperature and salinity for January 1, 1993.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"date = DateTimeProlepticGregorian(1993, 1, 1)\nset!(ocean.model, T=ECCOMetadata(:temperature; dates=date),\n                  S=ECCOMetadata(:salinity; dates=date))","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"[ Info: Inpainting ClimaOcean.DataWrangling.ECCO.ECCO4Monthly temperature data from 1993-01-01T00:00:00...\n[ Info:  ... (6.261 seconds)\n[ Info: Inpainting ClimaOcean.DataWrangling.ECCO.ECCO4Monthly salinity data from 1993-01-01T00:00:00...\n[ Info:  ... (919.584 ms)\n","category":"page"},{"location":"literated/near_global_ocean_simulation/#Prescribed-atmosphere-and-radiation","page":"Near-global Ocean simulation","title":"Prescribed atmosphere and radiation","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Next we build a prescribed atmosphere state and radiation model, which will drive the development of the ocean simulation. We use the default Radiation model,","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"# The radiation model specifies an ocean albedo emissivity to compute the net radiative\n# fluxes. The default ocean albedo is based on Payne (1982) and depends on cloud cover\n# (calculated from the ratio of maximum possible incident solar radiation to actual\n# incident solar radiation) and latitude. The ocean emissivity is set to 0.97.\n\nradiation = Radiation(arch)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Radiation{Float64}:\n├── stefan_boltzmann_constant: 5.67e-8\n├── emission: SurfaceProperties\n│   ├── ocean: 0.97\n│   └── sea_ice: 0.97\n└── reflection: SurfaceProperties\n    ├── ocean: LatitudeDepedendentAlbedo{Float64}: 0.069 - 0.011 ⋅ cos(2φ)\n    └── sea_ice: 0.7","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"The atmospheric data is prescribed using the JRA55 dataset. The number of snapshots that are loaded into memory is determined by the backend","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"into memory in 41 snapshots at a time. The JRA55 dataset provides atmospheric data such as temperature, humidity, and wind fields to calculate turbulent fluxes using bulk formulae, see CrossRealmFluxes.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"atmosphere = JRA55_prescribed_atmosphere(arch; backend=JRA55NetCDFBackend(41))","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"640×320×1×2920 PrescribedAtmosphere{Float32} on Oceananigans.Grids.LatitudeLongitudeGrid:\n├── times: 2920-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n├── reference_height: 10.0\n└── boundary_layer_height: 600.0","category":"page"},{"location":"literated/near_global_ocean_simulation/#The-coupled-simulation","page":"Near-global Ocean simulation","title":"The coupled simulation","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Next we assemble the ocean, atmosphere, and radiation into a coupled model,","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"coupled_model = OceanSeaIceModel(ocean; atmosphere, radiation)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"OceanSeaIceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── ocean: HydrostaticFreeSurfaceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── atmosphere: 640×320×1×2920 PrescribedAtmosphere{Float32}\n└── sea_ice: FreezingLimitedOceanTemperature{ClimaSeaIce.SeaIceThermodynamics.LinearLiquidus{Float64}}\n","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We then create a coupled simulation, starting with a time step of 10 seconds and running the simulation for 10 days.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"simulation = Simulation(coupled_model; Δt=90, stop_time=10days)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Simulation of OceanSeaIceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 1.500 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: 10 days\n├── Stop iteration: Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u_ocean on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We define a callback function to monitor the simulation's progress,","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"wall_time = Ref(time_ns())\n\nfunction progress(sim)\n    ocean = sim.model.ocean\n    u, v, w = ocean.model.velocities\n    T = ocean.model.tracers.T\n\n    Tmax = maximum(interior(T))\n    Tmin = minimum(interior(T))\n\n    umax = (maximum(abs, interior(u)),\n            maximum(abs, interior(v)),\n            maximum(abs, interior(w)))\n\n    step_time = 1e-9 * (time_ns() - wall_time[])\n\n    msg = @sprintf(\"Iter: %d, time: %s, Δt: %s\", iteration(sim), prettytime(sim), prettytime(sim.Δt))\n    msg *= @sprintf(\", max|u|: (%.2e, %.2e, %.2e) m s⁻¹, extrema(T): (%.2f, %.2f) ᵒC, wall time: %s\",\n                    umax..., Tmax, Tmin, prettytime(step_time))\n\n    @info msg\n\n    wall_time[] = time_ns()\nend\n\nsimulation.callbacks[:progress] = Callback(progress, TimeInterval(5days))","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"Callback of progress on TimeInterval(5 days)","category":"page"},{"location":"literated/near_global_ocean_simulation/#Set-up-output-writers","page":"Near-global Ocean simulation","title":"Set up output writers","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We define output writers to save the simulation data at regular intervals. In this case, we save the surface fluxes and surface fields at a relatively high frequency (every day). The indices keyword argument allows us to save down a slice at the surface, which is located at k = grid.Nz","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"outputs = merge(ocean.model.tracers, ocean.model.velocities)\nocean.output_writers[:surface] = JLD2OutputWriter(ocean.model, outputs;\n                                                  schedule = TimeInterval(1days),\n                                                  filename = \"near_global_surface_fields\",\n                                                  indices = (:, :, grid.Nz),\n                                                  with_halos = true,\n                                                  overwrite_existing = true,\n                                                  array_type = Array{Float32})","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"JLD2OutputWriter scheduled on TimeInterval(1 day):\n├── filepath: near_global_surface_fields.jld2\n├── 6 outputs: (T, S, e, u, v, w)\n├── array type: Array{Float32}\n├── including: [:grid, :coriolis, :buoyancy, :closure]\n├── file_splitting: NoFileSplitting\n└── file size: 13.8 MiB","category":"page"},{"location":"literated/near_global_ocean_simulation/#Spinning-up-the-simulation","page":"Near-global Ocean simulation","title":"Spinning up the simulation","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"We spin up the simulation with a very short time-step to resolve the \"initialization shock\" associated with starting from ECCO initial conditions that are both interpolated and also satisfy a different dynamical balance than our simulation.","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"run!(simulation)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"[ Info: Initializing simulation...\n[ Info: Iter: 0, time: 0 seconds, Δt: 1.500 minutes, max|u|: (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹, extrema(T): (31.25, -1.87) ᵒC, wall time: 2.439 minutes\n[ Info:     ... simulation initialization complete (6.573 seconds)\n[ Info: Executing initial time step...\n┌ Warning: Simulation stopped during initialization.\n└ @ Oceananigans.Simulations /central/scratch/esm/slurm-buildkite/climaocean-examples/1133/depot/default/packages/Oceananigans/ohMpu/src/Simulations/run.jl:129\n[ Info:     ... initial time step complete (2.613 minutes).\n[ Info: Iter: 4800, time: 5 days, Δt: 1.500 minutes, max|u|: (1.75e+00, 2.27e+00, 2.17e-02) m s⁻¹, extrema(T): (32.24, -1.88) ᵒC, wall time: 54.330 minutes\n[ Info: Simulation is stopping after running for 1.766 hours.\n[ Info: Simulation time 10 days equals or exceeds stop time 10 days.\n[ Info: Iter: 9600, time: 10 days, Δt: 1.500 minutes, max|u|: (2.02e+00, 2.05e+00, 1.19e-02) m s⁻¹, extrema(T): (33.27, -1.88) ᵒC, wall time: 51.671 minutes\n","category":"page"},{"location":"literated/near_global_ocean_simulation/#Running-the-simulation-for-real","page":"Near-global Ocean simulation","title":"Running the simulation for real","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"simulation.stop_time = 60days\nsimulation.Δt = 10minutes\nrun!(simulation)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"[ Info: Initializing simulation...\n[ Info:     ... simulation initialization complete (1.241 ms)\n[ Info: Executing initial time step...\n[ Info:     ... initial time step complete (8.459 seconds).\n[ Info: Iter: 10320, time: 15 days, Δt: 10 minutes, max|u|: (1.93e+00, 1.95e+00, 1.62e-02) m s⁻¹, extrema(T): (34.62, -1.88) ᵒC, wall time: 8.089 minutes\n[ Info: Iter: 11040, time: 20 days, Δt: 10 minutes, max|u|: (1.74e+00, 1.83e+00, 1.83e-02) m s⁻¹, extrema(T): (35.96, -1.88) ᵒC, wall time: 8.071 minutes\n[ Info: Iter: 11760, time: 25 days, Δt: 10 minutes, max|u|: (1.64e+00, 2.35e+00, 1.77e-02) m s⁻¹, extrema(T): (37.37, -1.88) ᵒC, wall time: 8.078 minutes\n[ Info: Iter: 12480, time: 30 days, Δt: 10 minutes, max|u|: (2.11e+00, 2.17e+00, 2.20e-02) m s⁻¹, extrema(T): (38.07, -1.88) ᵒC, wall time: 8.082 minutes\n[ Info: Iter: 13200, time: 35 days, Δt: 10 minutes, max|u|: (2.26e+00, 2.28e+00, 3.00e-02) m s⁻¹, extrema(T): (38.22, -1.88) ᵒC, wall time: 8.073 minutes\n[ Info: Iter: 13920, time: 40 days, Δt: 10 minutes, max|u|: (1.94e+00, 2.26e+00, 2.80e-02) m s⁻¹, extrema(T): (38.65, -1.88) ᵒC, wall time: 8.085 minutes\n[ Info: Iter: 14640, time: 45 days, Δt: 10 minutes, max|u|: (2.02e+00, 2.04e+00, 2.57e-02) m s⁻¹, extrema(T): (38.87, -1.88) ᵒC, wall time: 8.092 minutes\n[ Info: Iter: 15360, time: 50 days, Δt: 10 minutes, max|u|: (2.30e+00, 2.37e+00, 2.77e-02) m s⁻¹, extrema(T): (36.86, -1.88) ᵒC, wall time: 8.074 minutes\n[ Info: Iter: 16080, time: 55 days, Δt: 10 minutes, max|u|: (2.90e+00, 3.14e+00, 2.71e-02) m s⁻¹, extrema(T): (37.50, -1.88) ᵒC, wall time: 8.065 minutes\n[ Info: Simulation is stopping after running for 1.345 hours.\n[ Info: Simulation time 60 days equals or exceeds stop time 60 days.\n[ Info: Iter: 16800, time: 60 days, Δt: 10 minutes, max|u|: (1.94e+00, 1.65e+00, 2.55e-02) m s⁻¹, extrema(T): (37.62, -1.88) ᵒC, wall time: 8.060 minutes\n","category":"page"},{"location":"literated/near_global_ocean_simulation/#A-pretty-movie","page":"Near-global Ocean simulation","title":"A pretty movie","text":"","category":"section"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"It's time to make a pretty movie of the simulation. First we plot a snapshot:","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"u = FieldTimeSeries(\"near_global_surface_fields.jld2\", \"u\"; backend = OnDisk())\nv = FieldTimeSeries(\"near_global_surface_fields.jld2\", \"v\"; backend = OnDisk())\nT = FieldTimeSeries(\"near_global_surface_fields.jld2\", \"T\"; backend = OnDisk())\ne = FieldTimeSeries(\"near_global_surface_fields.jld2\", \"e\"; backend = OnDisk())\n\ntimes = u.times\nNt = length(times)\n\nn = Observable(Nt)\n\nland = interior(T.grid.immersed_boundary.bottom_height) .>= 0\n\nTn = @lift begin\n    Tn = interior(T[$n])\n    Tn[land] .= NaN\n    view(Tn, :, :, 1)\nend\n\nen = @lift begin\n    en = interior(e[$n])\n    en[land] .= NaN\n    view(en, :, :, 1)\nend\n\nun = Field{Face, Center, Nothing}(u.grid)\nvn = Field{Center, Face, Nothing}(v.grid)\ns = Field(sqrt(un^2 + vn^2))\n\nsn = @lift begin\n    parent(un) .= parent(u[$n])\n    parent(vn) .= parent(v[$n])\n    compute!(s)\n    sn = interior(s)\n    sn[land] .= NaN\n    view(sn, :, :, 1)\nend\n\nfig = Figure(size = (800, 1200))\n\naxs = Axis(fig[1, 1], xlabel=\"Longitude (deg)\", ylabel=\"Latitude (deg)\")\naxT = Axis(fig[2, 1], xlabel=\"Longitude (deg)\", ylabel=\"Latitude (deg)\")\naxe = Axis(fig[3, 1], xlabel=\"Longitude (deg)\", ylabel=\"Latitude (deg)\")\n\nhm = heatmap!(axs, sn, colorrange = (0, 0.5), colormap = :deep, nan_color=:lightgray)\nColorbar(fig[1, 2], hm, label = \"Surface speed (m s⁻¹)\")\n\nhm = heatmap!(axT, Tn, colorrange = (-1, 30), colormap = :magma, nan_color=:lightgray)\nColorbar(fig[2, 2], hm, label = \"Surface Temperature (ᵒC)\")\n\nhm = heatmap!(axe, en, colorrange = (0, 1e-3), colormap = :solar, nan_color=:lightgray)\nColorbar(fig[3, 2], hm, label = \"Turbulent Kinetic Energy (m² s⁻²)\")\nsave(\"snapshot.png\", fig)","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"(Image: )","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"And now a movie:","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"record(fig, \"near_global_ocean_surface.mp4\", 1:Nt, framerate = 8) do nn\n    n[] = nn\nend","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"(Image: )","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"","category":"page"},{"location":"literated/near_global_ocean_simulation/","page":"Near-global Ocean simulation","title":"Near-global Ocean simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"EditURL = \"../../../examples/generate_surface_fluxes.jl\"","category":"page"},{"location":"literated/generate_surface_fluxes/#Surface-fluxes-from-prescribed-ocean-and-atmosphere","page":"Surface fluxes","title":"Surface fluxes from prescribed ocean and atmosphere","text":"","category":"section"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"ClimaOcean uses bulk formulae to estimate the surface exchange of momentum, heat, and water vapor between the atmosphere and the ocean.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"This example demonstrates an example of the turbulent surface flux calculations performed in ClimaOcean using ECCO2 data for the ocean and JRA55 data for the atmosphere.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"For this example, we need ClimaOcean with its DataWrangling modules: ECCO2 and JRA55. We also need Oceananigans for the ImmersedBoundaryGrid and Field utilities, and CairoMakie to plot.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"using ClimaOcean\nusing ClimaOcean.ECCO\nusing ClimaOcean.JRA55\nusing ClimaOcean.OceanSimulations\nusing Oceananigans\nusing CairoMakie","category":"page"},{"location":"literated/generate_surface_fluxes/#Computing-fluxes-on-the-ECCO2-grid","page":"Surface fluxes","title":"Computing fluxes on the ECCO2 grid","text":"","category":"section"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"We start by building the ECCO2 grid, using ECCO_bottom_height to identify the bottom height.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"grid = ECCO_immersed_grid()\n\nfig = Figure()\nax  = Axis(fig[1, 1])\nheatmap!(ax, interior(grid.immersed_boundary.bottom_height, :, :, 1))","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"CairoMakie.Screen{IMAGE}\n","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"(Image: )","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"Next, we construct our atmosphere and ocean.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"The atmosphere is prescribed, downloaded from the JRA55 dataset. It contains:","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"zonal wind u\nmeridional wind v\nsurface temperature T\nsurface relative humidity q\nsurface pressure p\ndownwelling shortwave radiation\ndownwelling longwave radiation","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"We invoke the constructor with only the first two time indices, corresponding to January 1st (at 00:00 AM and 03:00 AM).","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"atmosphere = JRA55_prescribed_atmosphere(1:2; backend = InMemory())\nocean = ocean_simulation(grid)","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"Simulation of HydrostaticFreeSurfaceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 5 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: Inf days\n├── Stop iteration: Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"Now that we have an atmosphere and ocean, we set! the ocean temperature and salinity to the ECCO2 data by first creating T, S metadata objects,","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"T_metadata = ECCOMetadata(:temperature)\nS_metadata = ECCOMetadata(:salinity)","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"ECCOMetadata:\n├── name: salinity\n├── dates: CFTime.DateTimeProlepticGregorian(1993-01-01T00:00:00)\n├── version: ClimaOcean.DataWrangling.ECCO.ECCO4Monthly()\n└── dir: /central/scratch/esm/slurm-buildkite/climaocean-examples/1133/depot/default/scratchspaces/0376089a-ecfe-4b0e-a64f-9c555d74d754/ECCO","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"Note that if a date is not provided to ECCOMetadata, then the default Jan 1st, 1992 is used. To copy the ECCO state into ocean.model, we use set!,","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"set!(ocean.model; T=T_metadata, S=S_metadata)","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"[ Info: Inpainting ClimaOcean.DataWrangling.ECCO.ECCO4Monthly temperature data from 1993-01-01T00:00:00...\n[ Info:  ... (1.221 minutes)\n[ Info: Inpainting ClimaOcean.DataWrangling.ECCO.ECCO4Monthly salinity data from 1993-01-01T00:00:00...\n[ Info:  ... (1.223 minutes)\n","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"Finally, we construct a coupled model, which will compute fluxes during construction. We omit sea_ice so the model is ocean-only, and use the default Radiation() that uses the two-band shortwave (visible and UV) + longwave (mid and far infrared) decomposition of the radiation spectrum.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"coupled_model = OceanSeaIceModel(ocean; atmosphere, radiation=Radiation())","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"OceanSeaIceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── ocean: HydrostaticFreeSurfaceModel{CPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)\n├── atmosphere: 640×320×1×2 PrescribedAtmosphere{Float32}\n└── sea_ice: FreezingLimitedOceanTemperature{ClimaSeaIce.SeaIceThermodynamics.LinearLiquidus{Float64}}\n","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"Now that the surface fluxes are computed, we can extract and visualize them. The turbulent fluxes are stored in coupled_model.fluxes.turbulent.","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"fluxes  = coupled_model.fluxes.turbulent.fields\nλ, φ, z = nodes(fluxes.sensible_heat)\n\nfig = Figure(size = (800, 800), fontsize = 15)\n\nax = Axis(fig[1, 1], title = \"Sensible heat flux (W m⁻²)\", ylabel = \"Latitude\")\nheatmap!(ax, λ, φ, interior(fluxes.sensible_heat, :, :, 1); colormap = :bwr)\n\nax = Axis(fig[1, 2], title = \"Latent heat flux (W m⁻²)\")\nheatmap!(ax, λ, φ, interior(fluxes.latent_heat, :, :, 1); colormap = :bwr)\n\nax = Axis(fig[2, 1], title = \"Zonal wind stress (N m)\", ylabel = \"Latitude\")\nheatmap!(ax, λ, φ, interior(fluxes.x_momentum, :, :, 1); colormap = :bwr)\n\nax = Axis(fig[2, 2], title = \"Meridional wind stress (N m)\", xlabel = \"Longitude\")\nheatmap!(ax, λ, φ, interior(fluxes.y_momentum, :, :, 1); colormap = :bwr)\n\nax = Axis(fig[3, 1], title = \"Water vapor flux (kg m⁻² s⁻¹)\", xlabel = \"Longitude\", ylabel = \"Latitude\")\nheatmap!(ax, λ, φ, interior(fluxes.water_vapor, :, :, 1); colormap = :bwr)\n\nsave(\"fluxes.png\", fig)","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"CairoMakie.Screen{IMAGE}\n","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"(Image: )","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"","category":"page"},{"location":"literated/generate_surface_fluxes/","page":"Surface fluxes","title":"Surface fluxes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/function_index/#main-index","page":"Function index","title":"Index","text":"","category":"section"},{"location":"library/function_index/","page":"Function index","title":"Function index","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"library/outline/#Library-Outline","page":"Contents","title":"Library Outline","text":"","category":"section"},{"location":"library/outline/","page":"Contents","title":"Contents","text":"Pages = [\"public.md\", \"internals.md\", \"function_index.md\"]","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"EditURL = \"../../../examples/inspect_ecco_data.jl\"","category":"page"},{"location":"literated/inspect_ecco_data/#A-quick-look-at-ECCO-data","page":"Inspect ECCO2 data","title":"A quick look at ECCO data","text":"","category":"section"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"ClimaOcean can download and utilize data from the \"ECCO\" state estimate, which stands for \"Estimating the Circulation and Climate of the Ocean\" –- two!","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"This example shows how to download three-dimensional temperature and salinity fields from ECCO, and makes a short animation to showcase the fields' content.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"For this example we need Oceananigans for Field utilities, CairoMakie for plotting, Printf for nice labeling, and of course ClimaOcean to actually download and construct the ECCO fields.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"using Oceananigans\nusing CairoMakie\nusing Printf\n\nusing ClimaOcean.DataWrangling.ECCO: ECCO_field","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"The function ECCO_field provided by ClimaOcean.DataWrangling.ECCO automatically downloads ECCO data, if the data doesn't already exist at the default location.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"T = ECCO_field(:temperature)\nS = ECCO_field(:salinity)","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"720×360×50 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.LatitudeLongitudeGrid on Oceananigans.Architectures.CPU\n├── grid: 720×360×50 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 7×7×3 halo and with precomputed metrics\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux\n└── data: 734×374×56 OffsetArray(::Array{Float64, 3}, -6:727, -6:367, -2:53) with eltype Float64 with indices -6:727×-6:367×-2:53\n    └── max=40.6433, min=23.6947, mean=34.7526","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"Next, we massage the ECCO data by inserting NaNs in \"land cells\", which are diagnosed by having an unphysically low temperature.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"Tp = parent(T)\nSp = parent(S)\nSp[Tp .< -10] .= NaN\nTp[Tp .< -10] .= NaN","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"0-element view(::Vector{Float64}, Int64[]) with eltype Float64","category":"page"},{"location":"literated/inspect_ecco_data/#Plotting-ECCO-data","page":"Inspect ECCO2 data","title":"Plotting ECCO data","text":"","category":"section"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"We're ready to plot. We'll make an animation that depicts how the ECCO data changes with depth.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"fig = Figure(size=(900, 1050))\n\naxT = Axis(fig[1, 1])\naxS = Axis(fig[2, 1])","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"Axis with 0 plots:\n","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"To make an animation that scrolls through the 3D temperature and salinity fields, we make an Observable for the vertical index, and then construct slices of T, S using the Observable, k.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"grid = T.grid\nNz = size(grid, 3)\nk = Observable(Nz)\n\nTk = @lift view(T, :, :, $k)\nSk = @lift view(S, :, :, $k)","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"Observable(720×360×1 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.LatitudeLongitudeGrid on Oceananigans.Architectures.CPU\n├── grid: 720×360×50 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 7×7×3 halo and with precomputed metrics\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: Nothing, top: Nothing, immersed: ZeroFlux\n├── indices: (:, :, 50:50)\n└── data: 734×374×1 OffsetArray(view(::Array{Float64, 3}, :, :, 53:53), -6:727, -6:367, 50:50) with eltype Float64 with indices -6:727×-6:367×50:50\n    └── max=40.2086, min=23.6947, mean=34.0881)\n","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"Finally, we make a nice plot with a label that displays depth, colorbars, and light gray within land cells.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"hmT = heatmap!(axT, Tk, nan_color=:lightgray, colorrange=(-2, 30), colormap=:thermal)\nhmS = heatmap!(axS, Sk, nan_color=:lightgray, colorrange=(31, 37), colormap=:haline)\n\nColorbar(fig[1, 2], hmT, label=\"Temperature (ᵒC)\")\nColorbar(fig[2, 2], hmS, label=\"Salinity (psu)\")\n\nz = znodes(grid, Center())\ndepth_str = @lift @sprintf(\"z = %d meters\", z[$k])\ntext!(axT, 50, 50, text=depth_str, color=:lemonchiffon, justification=:center, fontsize=20)\ntext!(axS, 50, 50, text=depth_str, color=:lemonchiffon, justification=:center, fontsize=20)","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"MakieCore.Text{Tuple{Vector{GeometryBasics.Point{2, Float64}}}}","category":"page"},{"location":"literated/inspect_ecco_data/#Making-the-animation","page":"Inspect ECCO2 data","title":"Making the animation","text":"","category":"section"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"This animation is a little fancy. We start by displaying the surface field, then we scroll through depth to the bottom and pause there. Next, we scroll back to the surface and pause.","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"stillframes = 10\nmovingframes = Nz\n\nrecord(fig, \"ECCO_temperature_salinity.mp4\", framerate=4) do io\n\n    [recordframe!(io) for _ = 1:stillframes]\n\n    for kk in Nz:-2:1\n        k[] = kk\n        recordframe!(io)\n    end\n\n    [recordframe!(io) for _ = 1:stillframes]\n\n    for kk in 1:2:Nz\n        k[] = kk\n        recordframe!(io)\n    end\n\n    [recordframe!(io) for _ = 1:stillframes]\nend","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"(Image: )","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"","category":"page"},{"location":"literated/inspect_ecco_data/","page":"Inspect ECCO2 data","title":"Inspect ECCO2 data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"EditURL = \"../../../examples/single_column_os_papa_simulation.jl\"","category":"page"},{"location":"literated/single_column_os_papa_simulation/#Single-column-ocean-simulation-forced-by-JRA55-re-analysis","page":"Single column simulation","title":"Single column ocean simulation forced by JRA55 re-analysis","text":"","category":"section"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"In this example, we simulate the evolution of an ocean water column forced by an atmosphere derived from the JRA55 re-analysis. The simulated column is located at ocean station Papa (144.9ᵒ W and 50.1ᵒ N)","category":"page"},{"location":"literated/single_column_os_papa_simulation/#Install-dependencies","page":"Single column simulation","title":"Install dependencies","text":"","category":"section"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"First let's make sure we have all required packages installed.","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"using Pkg\npkg\"add Oceananigans, ClimaOcean, CairoMakie\"","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"using ClimaOcean\n\nusing Oceananigans\nusing Oceananigans.Units\nusing Oceananigans.BuoyancyModels: buoyancy_frequency\nusing Oceananigans.Units: Time\n\nusing CairoMakie\nusing Printf","category":"page"},{"location":"literated/single_column_os_papa_simulation/#Construct-the-grid","page":"Single column simulation","title":"Construct the grid","text":"","category":"section"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"First, we construct a single column grid with 2 meter spacing located at ocean station Papa.","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Ocean station papa location","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"location_name = \"ocean_station_papa\"\nλ★, φ★ = 35.1, 50.1\n\ngrid = RectilinearGrid(size = 200,\n                       x = λ★,\n                       y = φ★,\n                       z = (-400, 0),\n                       topology = (Flat, Flat, Bounded))","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── Flat x = 35.1              \n├── Flat y = 50.1              \n└── Bounded  z ∈ [-400.0, 0.0] regularly spaced with Δz=2.0","category":"page"},{"location":"literated/single_column_os_papa_simulation/#An-\"ocean-simulation\"","page":"Single column simulation","title":"An \"ocean simulation\"","text":"","category":"section"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Next, we use ClimaOcean's ocean_simulation constructor to build a realistic ocean simulation on the single column grid,","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"ocean = ocean_simulation(grid; Δt=10minutes, coriolis=FPlane(latitude = φ★))","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Simulation of HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── Next time step: 10 minutes\n├── Elapsed wall time: 0 seconds\n├── Wall time per iteration: NaN days\n├── Stop time: Inf days\n├── Stop iteration: Inf\n├── Wall time limit: Inf\n├── Callbacks: OrderedDict with 4 entries:\n│   ├── stop_time_exceeded => Callback of stop_time_exceeded on IterationInterval(1)\n│   ├── stop_iteration_exceeded => Callback of stop_iteration_exceeded on IterationInterval(1)\n│   ├── wall_time_limit_exceeded => Callback of wall_time_limit_exceeded on IterationInterval(1)\n│   └── nan_checker => Callback of NaNChecker for u on IterationInterval(100)\n├── Output writers: OrderedDict with no entries\n└── Diagnostics: OrderedDict with no entries","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"which wraps around the ocean model","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"ocean.model","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"HydrostaticFreeSurfaceModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── timestepper: QuasiAdamsBashforth2TimeStepper\n├── tracers: (T, S, e)\n├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}\n├── buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with ĝ = NegativeZDirection()\n├── advection scheme: \n│   ├── momentum: Nothing\n│   ├── T: Nothing\n│   ├── S: Nothing\n│   └── e: Nothing\n└── coriolis: Oceananigans.Coriolis.FPlane{Float64}","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"We set initial conditions from ECCO:","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"set!(ocean.model, T=ECCOMetadata(:temperature), S=ECCOMetadata(:salinity))","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"[ Info: Inpainting ClimaOcean.DataWrangling.ECCO.ECCO4Monthly temperature data from 1993-01-01T00:00:00...\n[ Info:  ... (1.220 minutes)\n[ Info: Inpainting ClimaOcean.DataWrangling.ECCO.ECCO4Monthly salinity data from 1993-01-01T00:00:00...\n[ Info:  ... (1.224 minutes)\n","category":"page"},{"location":"literated/single_column_os_papa_simulation/#A-prescribed-atmosphere-based-on-JRA55-re-analysis","page":"Single column simulation","title":"A prescribed atmosphere based on JRA55 re-analysis","text":"","category":"section"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"We build a PrescribedAtmosphere at the same location as the single colunm grid which is based on the JRA55 reanalysis.","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"simulation_days = 31\nsnapshots_per_day = 8 # corresponding to JRA55's 3-hour frequency\nlast_time = simulation_days * snapshots_per_day\natmosphere = JRA55_prescribed_atmosphere(1:last_time;\n                                         longitude = λ★,\n                                         latitude = φ★,\n                                         backend = InMemory())","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"2×2×1×248 PrescribedAtmosphere{Float32} on Oceananigans.Grids.LatitudeLongitudeGrid:\n├── times: 248-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}\n├── reference_height: 10.0\n└── boundary_layer_height: 600.0","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"This builds a representation of the atmosphere on the small grid","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"atmosphere.grid","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"2×2×1 LatitudeLongitudeGrid{Float32, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Oceananigans.Grids.Flat} on Oceananigans.Architectures.CPU with 2×2×0 halo and with precomputed metrics\n├── longitude: Bounded  λ ∈ [34.5938, 35.7188] variably spaced with min(Δλ)=0.5625, max(Δλ)=0.5625\n├── latitude:  Bounded  φ ∈ [49.4227, 50.5459] variably spaced with min(Δφ)=0.561619, max(Δφ)=0.561623\n└── z:         Flat z                          ","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Let's take a look at the atmospheric state","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"ua = interior(atmosphere.velocities.u, 1, 1, 1, :)\nva = interior(atmosphere.velocities.v, 1, 1, 1, :)\nTa = interior(atmosphere.tracers.T, 1, 1, 1, :)\nqa = interior(atmosphere.tracers.q, 1, 1, 1, :)\nt_days = atmosphere.times / days\n\nfig = Figure(size=(800, 600))\naxu = Axis(fig[2, 1], xlabel=\"Days since Jan 1 1990\", ylabel=\"Atmosphere \\n velocity (m s⁻¹)\")\naxT = Axis(fig[3, 1], xlabel=\"Days since Jan 1 1990\", ylabel=\"Atmosphere \\n temperature (K)\")\naxq = Axis(fig[4, 1], xlabel=\"Days since Jan 1 1990\", ylabel=\"Atmosphere \\n specific humidity\")\nLabel(fig[1, 1], \"Atmospheric state over ocean station Papa\", tellwidth=false)\n\nlines!(axu, t_days, ua, label=\"Zonal velocity\")\nlines!(axu, t_days, va, label=\"Meridional velocity\")\nylims!(axu, -6, 6)\naxislegend(axu, framevisible=false, nbanks=2, position=:lb)\n\nlines!(axT, t_days, Ta)\nlines!(axq, t_days, qa)\n\ndisplay(fig)\n\nradiation = Radiation()\ncoupled_model = OceanSeaIceModel(ocean; atmosphere, radiation)\nsimulation = Simulation(coupled_model, Δt=ocean.Δt, stop_time=30days)\n\nwall_clock = Ref(time_ns())\n\nfunction progress(sim)\n    msg = \"Ocean Station Papa\"\n    msg *= string(\", iter: \", iteration(sim), \", time: \", prettytime(sim))\n\n    elapsed = 1e-9 * (time_ns() - wall_clock[])\n    msg *= string(\", wall time: \", prettytime(elapsed))\n    wall_clock[] = time_ns()\n\n    u, v, w = sim.model.ocean.model.velocities\n    msg *= @sprintf(\", max|u|: (%.2e, %.2e)\", maximum(abs, u), maximum(abs, v))\n\n    T = sim.model.ocean.model.tracers.T\n    S = sim.model.ocean.model.tracers.S\n    e = sim.model.ocean.model.tracers.e\n\n    τx = first(sim.model.fluxes.total.ocean.momentum.u)\n    τy = first(sim.model.fluxes.total.ocean.momentum.v)\n    Q = first(sim.model.fluxes.total.ocean.heat)\n\n    u★ = sqrt(sqrt(τx^2 + τy^2))\n\n    Nz = size(T, 3)\n    msg *= @sprintf(\", u★: %.2f m s⁻¹\", u★)\n    msg *= @sprintf(\", Q: %.2f W m⁻²\",  Q)\n    msg *= @sprintf(\", T₀: %.2f ᵒC\", first(interior(T, 1, 1, Nz)))\n    msg *= @sprintf(\", extrema(T): (%.2f, %.2f) ᵒC\", minimum(T), maximum(T))\n    msg *= @sprintf(\", S₀: %.2f g/kg\", first(interior(S, 1, 1, Nz)))\n    msg *= @sprintf(\", e₀: %.2e m² s⁻²\", first(interior(e, 1, 1, Nz)))\n\n    @info msg\nend\n\nsimulation.callbacks[:progress] = Callback(progress, IterationInterval(100))","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Callback of progress on IterationInterval(100)","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Build flux outputs","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"τx = coupled_model.fluxes.total.ocean.momentum.u\nτy = coupled_model.fluxes.total.ocean.momentum.v\nJT = coupled_model.fluxes.total.ocean.tracers.T\nJs = coupled_model.fluxes.total.ocean.tracers.S\nE  = coupled_model.fluxes.turbulent.fields.water_vapor\nQc = coupled_model.fluxes.turbulent.fields.sensible_heat\nQv = coupled_model.fluxes.turbulent.fields.latent_heat\nρₒ = coupled_model.fluxes.ocean_reference_density\ncₚ = coupled_model.fluxes.ocean_heat_capacity\n\nQ = ρₒ * cₚ * JT\nρτx = ρₒ * τx\nρτy = ρₒ * τy\nN² = buoyancy_frequency(ocean.model)\nκc = ocean.model.diffusivity_fields.κc\n\nfluxes = (; ρτx, ρτy, E, Js, Qv, Qc)\nauxiliary_fields = (; N², κc)\nfields = merge(ocean.model.velocities, ocean.model.tracers, auxiliary_fields)","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"(u = 1×1×200 Field{Oceananigans.Grids.Face, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Flux, top: Flux, immersed: ZeroFlux\n└── data: 1×1×206 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:203) with eltype Float64 with indices 1:1×1:1×-2:203\n    └── max=0.0, min=0.0, mean=0.0, v = 1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Face, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Flux, top: Flux, immersed: ZeroFlux\n└── data: 1×1×206 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:203) with eltype Float64 with indices 1:1×1:1×-2:203\n    └── max=0.0, min=0.0, mean=0.0, w = ZeroField{Int64}, T = 1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Flux, immersed: ZeroFlux\n└── data: 1×1×206 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:203) with eltype Float64 with indices 1:1×1:1×-2:203\n    └── max=17.4568, min=14.8668, mean=16.0725, S = 1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Flux, immersed: ZeroFlux\n└── data: 1×1×206 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:203) with eltype Float64 with indices 1:1×1:1×-2:203\n    └── max=39.0664, min=38.5484, mean=38.9286, e = 1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: ZeroFlux, top: Flux, immersed: ZeroFlux\n└── data: 1×1×206 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:203) with eltype Float64 with indices 1:1×1:1×-2:203\n    └── max=0.0, min=0.0, mean=0.0, N² = KernelFunctionOperation at (Center, Center, Face)\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── kernel_function: ∂z_b (generic function with 4 methods)\n└── arguments: (\"SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64}\", \"(T=1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU, S=1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU, e=1×1×200 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Center} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU)\"), κc = 1×1×201 Field{Oceananigans.Grids.Center, Oceananigans.Grids.Center, Oceananigans.Grids.Face} on Oceananigans.Grids.RectilinearGrid on Oceananigans.Architectures.CPU\n├── grid: 1×1×200 RectilinearGrid{Float64, Oceananigans.Grids.Flat, Oceananigans.Grids.Flat, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 0×0×3 halo\n├── boundary conditions: FieldBoundaryConditions\n│   └── west: Nothing, east: Nothing, south: Nothing, north: Nothing, bottom: Nothing, top: Nothing, immersed: ZeroFlux\n└── data: 1×1×207 OffsetArray(::Array{Float64, 3}, 1:1, 1:1, -2:204) with eltype Float64 with indices 1:1×1:1×-2:204\n    └── max=4.09156e-5, min=0.0, mean=3.04304e-7)","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"Slice fields at the surface","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"outputs = merge(fields, fluxes)\n\nfilename = \"single_column_omip_$(location_name)\"\n\nsimulation.output_writers[:jld2] = JLD2OutputWriter(ocean.model, outputs; filename,\n                                                    schedule = TimeInterval(3hours),\n                                                    overwrite_existing = true)\n\nrun!(simulation)\n\nfilename *= \".jld2\"\n\nu  = FieldTimeSeries(filename, \"u\")\nv  = FieldTimeSeries(filename, \"v\")\nT  = FieldTimeSeries(filename, \"T\")\nS  = FieldTimeSeries(filename, \"S\")\ne  = FieldTimeSeries(filename, \"e\")\nN² = FieldTimeSeries(filename, \"N²\")\nκ  = FieldTimeSeries(filename, \"κc\")\n\nQv = FieldTimeSeries(filename, \"Qv\")\nQc = FieldTimeSeries(filename, \"Qc\")\nJs = FieldTimeSeries(filename, \"Js\")\nEv = FieldTimeSeries(filename, \"E\")\nρτx = FieldTimeSeries(filename, \"ρτx\")\nρτy = FieldTimeSeries(filename, \"ρτy\")\n\nNz = size(T, 3)\ntimes = Qc.times\n\nua  = atmosphere.velocities.u\nva  = atmosphere.velocities.v\nTa  = atmosphere.tracers.T\nqa  = atmosphere.tracers.q\nQlw = atmosphere.downwelling_radiation.longwave\nQsw = atmosphere.downwelling_radiation.shortwave\nPr  = atmosphere.freshwater_flux.rain\nPs  = atmosphere.freshwater_flux.snow\n\nNt   = length(times)\nuat  = zeros(Nt)\nvat  = zeros(Nt)\nTat  = zeros(Nt)\nqat  = zeros(Nt)\nQswt = zeros(Nt)\nQlwt = zeros(Nt)\nPt   = zeros(Nt)\n\nfor n = 1:Nt\n    t = times[n]\n    uat[n]  =  ua[1, 1, 1, Time(t)]\n    vat[n]  =  va[1, 1, 1, Time(t)]\n    Tat[n]  =  Ta[1, 1, 1, Time(t)]\n    qat[n]  =  qa[1, 1, 1, Time(t)]\n    Qswt[n] = Qsw[1, 1, 1, Time(t)]\n    Qlwt[n] = Qlw[1, 1, 1, Time(t)]\n    Pt[n]   =  Pr[1, 1, 1, Time(t)] + Ps[1, 1, 1, Time(t)]\nend\n\nset_theme!(Theme(linewidth=3))\n\nfig = Figure(size=(2400, 1800))\n\naxτ = Axis(fig[1, 1:2], xlabel=\"Days since Oct 1 1992\", ylabel=\"Wind stress (N m⁻²)\")\naxu = Axis(fig[2, 1:2], xlabel=\"Days since Oct 1 1992\", ylabel=\"Velocities (m s⁻¹)\")\naxQ = Axis(fig[1, 3:4], xlabel=\"Days since Oct 1 1992\", ylabel=\"Heat flux (W m⁻²)\")\naxT = Axis(fig[2, 3:4], xlabel=\"Days since Oct 1 1992\", ylabel=\"Surface temperature (ᵒC)\")\naxF = Axis(fig[1, 5:6], xlabel=\"Days since Oct 1 1992\", ylabel=\"Freshwater volume flux (m s⁻¹)\")\naxS = Axis(fig[2, 5:6], xlabel=\"Days since Oct 1 1992\", ylabel=\"Surface salinity (g kg⁻¹)\")\n\naxuz = Axis(fig[3, 1], xlabel=\"Velocities (m s⁻¹)\",                ylabel=\"z (m)\")\naxTz = Axis(fig[3, 2], xlabel=\"Temperature (ᵒC)\",                  ylabel=\"z (m)\")\naxSz = Axis(fig[3, 3], xlabel=\"Salinity (g kg⁻¹)\",                 ylabel=\"z (m)\")\naxNz = Axis(fig[3, 4], xlabel=\"Buoyancy frequency (s⁻²)\",          ylabel=\"z (m)\")\naxκz = Axis(fig[3, 5], xlabel=\"Eddy diffusivity (m² s⁻¹)\",         ylabel=\"z (m)\", xscale=log10)\naxez = Axis(fig[3, 6], xlabel=\"Turbulent kinetic energy (m² s⁻²)\", ylabel=\"z (m)\", xscale=log10)\n\ntitle = @sprintf(\"Single column simulation at %.2f, %.2f\", φ★, λ★)\nLabel(fig[0, 1:6], title)\n\nslider = Slider(fig[4, 1:6], range=1:Nt, startvalue=1)\nn = slider.value\n\ntimes = (times .- times[1]) ./days\nNt = length(times)\ntn = @lift times[$n]\n\ncolors = Makie.wong_colors()\n\nρₒ = coupled_model.fluxes.ocean_reference_density\nτx = interior(ρτx, 1, 1, 1, :) ./ ρₒ\nτy = interior(ρτy, 1, 1, 1, :) ./ ρₒ\nu★ = @. (τx^2 + τy^2)^(1/4)\n\nlines!(axu, times, interior(u, 1, 1, Nz, :), color=colors[1], label=\"Zonal\")\nlines!(axu, times, interior(v, 1, 1, Nz, :), color=colors[2], label=\"Meridional\")\nlines!(axu, times, u★, color=colors[3], label=\"Ocean-side u★\")\nvlines!(axu, tn, linewidth=4, color=(:black, 0.5))\naxislegend(axu)\n\nlines!(axτ, times, interior(ρτx, 1, 1, 1, :), label=\"Zonal\")\nlines!(axτ, times, interior(ρτy, 1, 1, 1, :), label=\"Meridional\")\nvlines!(axτ, tn, linewidth=4, color=(:black, 0.5))\naxislegend(axτ)\n\nlines!(axT, times, Tat[1:Nt] .- 273.15,      color=colors[1], linewidth=2, linestyle=:dash, label=\"Atmosphere temperature\")\nlines!(axT, times, interior(T, 1, 1, Nz, :), color=colors[2], linewidth=4, label=\"Ocean surface temperature\")\nvlines!(axT, tn, linewidth=4, color=(:black, 0.5))\naxislegend(axT)\n\nlines!(axQ, times, interior(Qv, 1, 1, 1, 1:Nt),    color=colors[2], label=\"Sensible\",  linewidth=2)\nlines!(axQ, times, interior(Qc, 1, 1, 1, 1:Nt),    color=colors[3], label=\"Latent\",    linewidth=2)\nlines!(axQ, times, - interior(Qsw, 1, 1, 1, 1:Nt), color=colors[4], label=\"Shortwave\", linewidth=2)\nlines!(axQ, times, - interior(Qlw, 1, 1, 1, 1:Nt), color=colors[5], label=\"Longwave\",  linewidth=2)\nvlines!(axQ, tn, linewidth=4, color=(:black, 0.5))\naxislegend(axQ)\n\nlines!(axF, times, Pt[1:Nt], label=\"Prescribed freshwater flux\")\nlines!(axF, times, - interior(Ev, 1, 1, 1, 1:Nt), label=\"Evaporation\")\nvlines!(axF, tn, linewidth=4, color=(:black, 0.5))\naxislegend(axF)\n\nlines!(axS, times, interior(S, 1, 1, Nz, :))\nvlines!(axS, tn, linewidth=4, color=(:black, 0.5))\n\nzc = znodes(T)\nzf = znodes(κ)\nun  = @lift interior(u[$n],  1, 1, :)\nvn  = @lift interior(v[$n],  1, 1, :)\nTn  = @lift interior(T[$n],  1, 1, :)\nSn  = @lift interior(S[$n],  1, 1, :)\nκn  = @lift interior(κ[$n],  1, 1, :)\nen  = @lift interior(e[$n],  1, 1, :)\nN²n = @lift interior(N²[$n], 1, 1, :)\n\nscatterlines!(axuz, un,  zc, label=\"u\")\nscatterlines!(axuz, vn,  zc, label=\"v\")\nscatterlines!(axTz, Tn,  zc)\nscatterlines!(axSz, Sn,  zc)\nscatterlines!(axez, en,  zc)\nscatterlines!(axNz, N²n, zf)\nscatterlines!(axκz, κn,  zf)\n\naxislegend(axuz)\n\nTmax = maximum(interior(T))\nTmin = minimum(interior(T))\nxlims!(axTz, Tmin - 0.1, Tmax + 0.1)\n\nNmax = maximum(interior(N²))\nNmin = minimum(interior(N²))\nxlims!(axNz, Nmin / 2, Nmin * 1.1)\n\nemax = maximum(interior(e))\nxlims!(axez, 8e-7, emax * 1.1)\nxlims!(axκz, 1e-7, 10)\n\nSmax = maximum(interior(S))\nSmin = minimum(interior(S))\nxlims!(axSz, Smin - 0.2, Smax + 0.2)\n\nrecord(fig, \"single_column_profiles.mp4\", 1:2:Nt, framerate=24) do nn\n    @info \"Drawing frame $nn of $Nt...\"\n    n[] = nn\nend","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"[ Info: Initializing simulation...\n[ Info: Ocean Station Papa, iter: 0, time: 0 seconds, wall time: 2.679 minutes, max|u|: (0.00e+00, 0.00e+00), u★: 0.00 m s⁻¹, Q: 232.78 W m⁻², T₀: 17.38 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.55 g/kg, e₀: 0.00e+00 m² s⁻²\n[ Info:     ... simulation initialization complete (5.380 minutes)\n[ Info: Executing initial time step...\n┌ Warning: Simulation stopped during initialization.\n└ @ Oceananigans.Simulations /central/scratch/esm/slurm-buildkite/climaocean-examples/1133/depot/default/packages/Oceananigans/ohMpu/src/Simulations/run.jl:129\n[ Info:     ... initial time step complete (14.426 seconds).\n[ Info: Ocean Station Papa, iter: 100, time: 16.667 hours, wall time: 5.911 minutes, max|u|: (1.53e-04, 7.64e-04), u★: 0.00 m s⁻¹, Q: 261.26 W m⁻², T₀: 17.34 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 3.19e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 200, time: 1.389 days, wall time: 813.396 ms, max|u|: (3.01e-04, 1.90e-03), u★: 0.00 m s⁻¹, Q: 181.47 W m⁻², T₀: 17.30 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 1.82e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 300, time: 2.083 days, wall time: 700.686 ms, max|u|: (1.70e-04, 9.27e-04), u★: 0.00 m s⁻¹, Q: 191.75 W m⁻², T₀: 17.27 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 2.46e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 400, time: 2.778 days, wall time: 776.033 ms, max|u|: (1.30e-03, 1.29e-03), u★: 0.00 m s⁻¹, Q: 242.76 W m⁻², T₀: 17.24 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 2.27e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 500, time: 3.472 days, wall time: 810.164 ms, max|u|: (1.34e-03, 6.33e-04), u★: 0.00 m s⁻¹, Q: 254.63 W m⁻², T₀: 17.20 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 3.01e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 600, time: 4.167 days, wall time: 878.523 ms, max|u|: (7.67e-04, 1.43e-03), u★: 0.00 m s⁻¹, Q: 212.42 W m⁻², T₀: 17.15 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 2.49e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 700, time: 4.861 days, wall time: 836.139 ms, max|u|: (5.52e-05, 1.88e-03), u★: 0.00 m s⁻¹, Q: 175.63 W m⁻², T₀: 17.13 ᵒC, extrema(T): (14.87, 17.46) ᵒC, S₀: 38.56 g/kg, e₀: 2.16e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 800, time: 5.556 days, wall time: 938.834 ms, max|u|: (8.14e-04, 1.52e-03), u★: 0.00 m s⁻¹, Q: 166.69 W m⁻², T₀: 17.10 ᵒC, extrema(T): (14.87, 17.39) ᵒC, S₀: 38.57 g/kg, e₀: 2.55e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 900, time: 6.250 days, wall time: 904.285 ms, max|u|: (2.19e-03, 1.44e-03), u★: 0.00 m s⁻¹, Q: 186.30 W m⁻², T₀: 17.07 ᵒC, extrema(T): (14.87, 17.36) ᵒC, S₀: 38.57 g/kg, e₀: 2.44e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1000, time: 6.944 days, wall time: 1.025 seconds, max|u|: (1.89e-03, 1.80e-04), u★: 0.00 m s⁻¹, Q: 183.07 W m⁻², T₀: 17.04 ᵒC, extrema(T): (14.87, 17.36) ᵒC, S₀: 38.57 g/kg, e₀: 2.63e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1100, time: 7.639 days, wall time: 967.891 ms, max|u|: (2.64e-03, 8.74e-04), u★: 0.00 m s⁻¹, Q: 196.86 W m⁻², T₀: 17.02 ᵒC, extrema(T): (14.87, 17.28) ᵒC, S₀: 38.57 g/kg, e₀: 2.49e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1200, time: 8.333 days, wall time: 1.049 seconds, max|u|: (1.88e-03, 5.63e-04), u★: 0.00 m s⁻¹, Q: 85.95 W m⁻², T₀: 16.99 ᵒC, extrema(T): (14.87, 17.27) ᵒC, S₀: 38.57 g/kg, e₀: 1.70e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1300, time: 9.028 days, wall time: 1.353 seconds, max|u|: (1.90e-03, 1.24e-03), u★: 0.00 m s⁻¹, Q: 195.95 W m⁻², T₀: 16.96 ᵒC, extrema(T): (14.87, 17.27) ᵒC, S₀: 38.58 g/kg, e₀: 3.03e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1400, time: 9.722 days, wall time: 1.291 seconds, max|u|: (1.28e-03, 2.06e-03), u★: 0.00 m s⁻¹, Q: 184.79 W m⁻², T₀: 16.93 ᵒC, extrema(T): (14.87, 17.21) ᵒC, S₀: 38.58 g/kg, e₀: 2.51e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1500, time: 10.417 days, wall time: 1.285 seconds, max|u|: (3.36e-03, 4.39e-03), u★: 0.00 m s⁻¹, Q: 239.17 W m⁻², T₀: 16.89 ᵒC, extrema(T): (14.87, 17.17) ᵒC, S₀: 38.58 g/kg, e₀: 3.04e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1600, time: 11.111 days, wall time: 1.179 seconds, max|u|: (1.69e-03, 3.12e-03), u★: 0.00 m s⁻¹, Q: 212.68 W m⁻², T₀: 16.86 ᵒC, extrema(T): (14.87, 17.17) ᵒC, S₀: 38.58 g/kg, e₀: 2.86e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1700, time: 11.806 days, wall time: 1.563 seconds, max|u|: (8.60e-05, 3.05e-03), u★: 0.00 m s⁻¹, Q: 137.42 W m⁻², T₀: 16.84 ᵒC, extrema(T): (14.87, 17.13) ᵒC, S₀: 38.59 g/kg, e₀: 1.90e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1800, time: 12.500 days, wall time: 1.166 seconds, max|u|: (1.55e-03, 3.15e-03), u★: 0.00 m s⁻¹, Q: 202.47 W m⁻², T₀: 16.82 ᵒC, extrema(T): (14.87, 17.09) ᵒC, S₀: 38.59 g/kg, e₀: 2.57e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 1900, time: 13.194 days, wall time: 1.607 seconds, max|u|: (2.32e-03, 3.97e-03), u★: 0.00 m s⁻¹, Q: 247.62 W m⁻², T₀: 16.78 ᵒC, extrema(T): (14.87, 17.08) ᵒC, S₀: 38.59 g/kg, e₀: 3.61e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2000, time: 13.889 days, wall time: 1.619 seconds, max|u|: (1.25e-03, 3.32e-03), u★: 0.00 m s⁻¹, Q: 360.37 W m⁻², T₀: 16.73 ᵒC, extrema(T): (14.87, 17.04) ᵒC, S₀: 38.59 g/kg, e₀: 3.97e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2100, time: 14.583 days, wall time: 1.520 seconds, max|u|: (2.02e-03, 2.70e-03), u★: 0.00 m s⁻¹, Q: 298.53 W m⁻², T₀: 16.69 ᵒC, extrema(T): (14.87, 16.98) ᵒC, S₀: 38.60 g/kg, e₀: 3.42e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2200, time: 15.278 days, wall time: 1.463 seconds, max|u|: (1.97e-03, 1.56e-03), u★: 0.00 m s⁻¹, Q: 218.40 W m⁻², T₀: 16.64 ᵒC, extrema(T): (14.87, 16.98) ᵒC, S₀: 38.60 g/kg, e₀: 3.15e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2300, time: 15.972 days, wall time: 1.428 seconds, max|u|: (2.18e-03, 8.61e-04), u★: 0.00 m s⁻¹, Q: 280.61 W m⁻², T₀: 16.60 ᵒC, extrema(T): (14.87, 16.90) ᵒC, S₀: 38.60 g/kg, e₀: 3.56e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2400, time: 16.667 days, wall time: 1.389 seconds, max|u|: (1.89e-03, 3.03e-04), u★: 0.00 m s⁻¹, Q: 223.01 W m⁻², T₀: 16.57 ᵒC, extrema(T): (14.87, 16.90) ᵒC, S₀: 38.61 g/kg, e₀: 2.93e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2500, time: 17.361 days, wall time: 1.413 seconds, max|u|: (1.88e-03, 1.26e-03), u★: 0.00 m s⁻¹, Q: 81.78 W m⁻², T₀: 16.54 ᵒC, extrema(T): (14.87, 16.90) ᵒC, S₀: 38.61 g/kg, e₀: 1.83e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2600, time: 18.056 days, wall time: 1.446 seconds, max|u|: (1.14e-03, 1.59e-03), u★: 0.00 m s⁻¹, Q: 262.60 W m⁻², T₀: 16.51 ᵒC, extrema(T): (14.87, 16.88) ᵒC, S₀: 38.61 g/kg, e₀: 3.74e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2700, time: 18.750 days, wall time: 1.592 seconds, max|u|: (2.33e-04, 1.24e-03), u★: 0.00 m s⁻¹, Q: 286.11 W m⁻², T₀: 16.49 ᵒC, extrema(T): (14.87, 16.82) ᵒC, S₀: 38.61 g/kg, e₀: 3.79e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2800, time: 19.444 days, wall time: 1.072 seconds, max|u|: (4.81e-04, 1.23e-03), u★: 0.00 m s⁻¹, Q: 163.27 W m⁻², T₀: 16.45 ᵒC, extrema(T): (14.87, 16.82) ᵒC, S₀: 38.61 g/kg, e₀: 2.16e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 2900, time: 20.139 days, wall time: 1.189 seconds, max|u|: (9.19e-04, 1.13e-03), u★: 0.00 m s⁻¹, Q: 224.43 W m⁻², T₀: 16.42 ᵒC, extrema(T): (14.87, 16.82) ᵒC, S₀: 38.62 g/kg, e₀: 3.48e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3000, time: 20.833 days, wall time: 991.651 ms, max|u|: (1.63e-03, 9.63e-05), u★: 0.00 m s⁻¹, Q: 264.77 W m⁻², T₀: 16.39 ᵒC, extrema(T): (14.87, 16.77) ᵒC, S₀: 38.62 g/kg, e₀: 3.82e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3100, time: 21.528 days, wall time: 1.217 seconds, max|u|: (1.49e-03, 5.81e-04), u★: 0.00 m s⁻¹, Q: 220.15 W m⁻², T₀: 16.36 ᵒC, extrema(T): (14.87, 16.74) ᵒC, S₀: 38.62 g/kg, e₀: 2.92e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3200, time: 22.222 days, wall time: 1.057 seconds, max|u|: (9.29e-04, 1.01e-03), u★: 0.00 m s⁻¹, Q: 143.97 W m⁻², T₀: 16.33 ᵒC, extrema(T): (14.87, 16.74) ᵒC, S₀: 38.62 g/kg, e₀: 2.68e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3300, time: 22.917 days, wall time: 1.392 seconds, max|u|: (5.07e-04, 1.81e-03), u★: 0.00 m s⁻¹, Q: 226.24 W m⁻², T₀: 16.31 ᵒC, extrema(T): (14.87, 16.74) ᵒC, S₀: 38.62 g/kg, e₀: 3.35e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3400, time: 23.611 days, wall time: 877.320 ms, max|u|: (5.92e-04, 2.12e-03), u★: 0.00 m s⁻¹, Q: 202.04 W m⁻², T₀: 16.28 ᵒC, extrema(T): (14.87, 16.68) ᵒC, S₀: 38.63 g/kg, e₀: 2.55e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3500, time: 24.306 days, wall time: 981.604 ms, max|u|: (1.05e-03, 1.18e-03), u★: 0.00 m s⁻¹, Q: 127.61 W m⁻², T₀: 16.25 ᵒC, extrema(T): (14.87, 16.66) ᵒC, S₀: 38.63 g/kg, e₀: 2.47e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3600, time: 25 days, wall time: 863.657 ms, max|u|: (3.03e-03, 2.64e-03), u★: 0.01 m s⁻¹, Q: 410.07 W m⁻², T₀: 16.21 ᵒC, extrema(T): (14.87, 16.66) ᵒC, S₀: 38.63 g/kg, e₀: 4.56e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3700, time: 25.694 days, wall time: 1.189 seconds, max|u|: (9.61e-04, 2.46e-03), u★: 0.00 m s⁻¹, Q: 343.23 W m⁻², T₀: 16.17 ᵒC, extrema(T): (14.87, 16.58) ᵒC, S₀: 38.64 g/kg, e₀: 4.45e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3800, time: 26.389 days, wall time: 1.021 seconds, max|u|: (8.11e-04, 1.80e-03), u★: 0.00 m s⁻¹, Q: 163.10 W m⁻², T₀: 16.13 ᵒC, extrema(T): (14.87, 16.58) ᵒC, S₀: 38.64 g/kg, e₀: 2.43e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 3900, time: 27.083 days, wall time: 1.039 seconds, max|u|: (1.40e-04, 1.55e-03), u★: 0.00 m s⁻¹, Q: 406.33 W m⁻², T₀: 16.08 ᵒC, extrema(T): (14.87, 16.53) ᵒC, S₀: 38.64 g/kg, e₀: 4.84e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 4000, time: 27.778 days, wall time: 1.323 seconds, max|u|: (3.16e-04, 1.98e-03), u★: 0.00 m s⁻¹, Q: 395.20 W m⁻², T₀: 16.04 ᵒC, extrema(T): (14.87, 16.53) ᵒC, S₀: 38.65 g/kg, e₀: 4.72e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 4100, time: 28.472 days, wall time: 964.564 ms, max|u|: (4.29e-04, 1.55e-03), u★: 0.00 m s⁻¹, Q: 227.02 W m⁻², T₀: 16.00 ᵒC, extrema(T): (14.87, 16.49) ᵒC, S₀: 38.65 g/kg, e₀: 2.93e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 4200, time: 29.167 days, wall time: 1.371 seconds, max|u|: (1.21e-03, 6.53e-04), u★: 0.00 m s⁻¹, Q: 219.16 W m⁻², T₀: 15.97 ᵒC, extrema(T): (14.87, 16.49) ᵒC, S₀: 38.65 g/kg, e₀: 3.18e-04 m² s⁻²\n[ Info: Ocean Station Papa, iter: 4300, time: 29.861 days, wall time: 1.252 seconds, max|u|: (1.98e-03, 2.05e-04), u★: 0.00 m s⁻¹, Q: 355.56 W m⁻², T₀: 15.94 ᵒC, extrema(T): (14.87, 16.49) ᵒC, S₀: 38.65 g/kg, e₀: 4.08e-04 m² s⁻²\n[ Info: Simulation is stopping after running for 6.752 minutes.\n[ Info: Simulation time 30 days equals or exceeds stop time 30 days.\n[ Info: Drawing frame 1 of 241...\n[ Info: Drawing frame 3 of 241...\n[ Info: Drawing frame 5 of 241...\n[ Info: Drawing frame 7 of 241...\n[ Info: Drawing frame 9 of 241...\n[ Info: Drawing frame 11 of 241...\n[ Info: Drawing frame 13 of 241...\n[ Info: Drawing frame 15 of 241...\n[ Info: Drawing frame 17 of 241...\n[ Info: Drawing frame 19 of 241...\n[ Info: Drawing frame 21 of 241...\n[ Info: Drawing frame 23 of 241...\n[ Info: Drawing frame 25 of 241...\n[ Info: Drawing frame 27 of 241...\n[ Info: Drawing frame 29 of 241...\n[ Info: Drawing frame 31 of 241...\n[ Info: Drawing frame 33 of 241...\n[ Info: Drawing frame 35 of 241...\n[ Info: Drawing frame 37 of 241...\n[ Info: Drawing frame 39 of 241...\n[ Info: Drawing frame 41 of 241...\n[ Info: Drawing frame 43 of 241...\n[ Info: Drawing frame 45 of 241...\n[ Info: Drawing frame 47 of 241...\n[ Info: Drawing frame 49 of 241...\n[ Info: Drawing frame 51 of 241...\n[ Info: Drawing frame 53 of 241...\n[ Info: Drawing frame 55 of 241...\n[ Info: Drawing frame 57 of 241...\n[ Info: Drawing frame 59 of 241...\n[ Info: Drawing frame 61 of 241...\n[ Info: Drawing frame 63 of 241...\n[ Info: Drawing frame 65 of 241...\n[ Info: Drawing frame 67 of 241...\n[ Info: Drawing frame 69 of 241...\n[ Info: Drawing frame 71 of 241...\n[ Info: Drawing frame 73 of 241...\n[ Info: Drawing frame 75 of 241...\n[ Info: Drawing frame 77 of 241...\n[ Info: Drawing frame 79 of 241...\n[ Info: Drawing frame 81 of 241...\n[ Info: Drawing frame 83 of 241...\n[ Info: Drawing frame 85 of 241...\n[ Info: Drawing frame 87 of 241...\n[ Info: Drawing frame 89 of 241...\n[ Info: Drawing frame 91 of 241...\n[ Info: Drawing frame 93 of 241...\n[ Info: Drawing frame 95 of 241...\n[ Info: Drawing frame 97 of 241...\n[ Info: Drawing frame 99 of 241...\n[ Info: Drawing frame 101 of 241...\n[ Info: Drawing frame 103 of 241...\n[ Info: Drawing frame 105 of 241...\n[ Info: Drawing frame 107 of 241...\n[ Info: Drawing frame 109 of 241...\n[ Info: Drawing frame 111 of 241...\n[ Info: Drawing frame 113 of 241...\n[ Info: Drawing frame 115 of 241...\n[ Info: Drawing frame 117 of 241...\n[ Info: Drawing frame 119 of 241...\n[ Info: Drawing frame 121 of 241...\n[ Info: Drawing frame 123 of 241...\n[ Info: Drawing frame 125 of 241...\n[ Info: Drawing frame 127 of 241...\n[ Info: Drawing frame 129 of 241...\n[ Info: Drawing frame 131 of 241...\n[ Info: Drawing frame 133 of 241...\n[ Info: Drawing frame 135 of 241...\n[ Info: Drawing frame 137 of 241...\n[ Info: Drawing frame 139 of 241...\n[ Info: Drawing frame 141 of 241...\n[ Info: Drawing frame 143 of 241...\n[ Info: Drawing frame 145 of 241...\n[ Info: Drawing frame 147 of 241...\n[ Info: Drawing frame 149 of 241...\n[ Info: Drawing frame 151 of 241...\n[ Info: Drawing frame 153 of 241...\n[ Info: Drawing frame 155 of 241...\n[ Info: Drawing frame 157 of 241...\n[ Info: Drawing frame 159 of 241...\n[ Info: Drawing frame 161 of 241...\n[ Info: Drawing frame 163 of 241...\n[ Info: Drawing frame 165 of 241...\n[ Info: Drawing frame 167 of 241...\n[ Info: Drawing frame 169 of 241...\n[ Info: Drawing frame 171 of 241...\n[ Info: Drawing frame 173 of 241...\n[ Info: Drawing frame 175 of 241...\n[ Info: Drawing frame 177 of 241...\n[ Info: Drawing frame 179 of 241...\n[ Info: Drawing frame 181 of 241...\n[ Info: Drawing frame 183 of 241...\n[ Info: Drawing frame 185 of 241...\n[ Info: Drawing frame 187 of 241...\n[ Info: Drawing frame 189 of 241...\n[ Info: Drawing frame 191 of 241...\n[ Info: Drawing frame 193 of 241...\n[ Info: Drawing frame 195 of 241...\n[ Info: Drawing frame 197 of 241...\n[ Info: Drawing frame 199 of 241...\n[ Info: Drawing frame 201 of 241...\n[ Info: Drawing frame 203 of 241...\n[ Info: Drawing frame 205 of 241...\n[ Info: Drawing frame 207 of 241...\n[ Info: Drawing frame 209 of 241...\n[ Info: Drawing frame 211 of 241...\n[ Info: Drawing frame 213 of 241...\n[ Info: Drawing frame 215 of 241...\n[ Info: Drawing frame 217 of 241...\n[ Info: Drawing frame 219 of 241...\n[ Info: Drawing frame 221 of 241...\n[ Info: Drawing frame 223 of 241...\n[ Info: Drawing frame 225 of 241...\n[ Info: Drawing frame 227 of 241...\n[ Info: Drawing frame 229 of 241...\n[ Info: Drawing frame 231 of 241...\n[ Info: Drawing frame 233 of 241...\n[ Info: Drawing frame 235 of 241...\n[ Info: Drawing frame 237 of 241...\n[ Info: Drawing frame 239 of 241...\n[ Info: Drawing frame 241 of 241...\n","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"(Image: )","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"","category":"page"},{"location":"literated/single_column_os_papa_simulation/","page":"Single column simulation","title":"Single column simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"library/internals/#Private-types-and-functions","page":"Private","title":"Private types and functions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Documentation for ClimaOcean.jl's internal interface.","category":"page"},{"location":"library/internals/#ClimaOcean","page":"Private","title":"ClimaOcean","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean]\nPublic = false","category":"page"},{"location":"library/internals/#Diagnostics","page":"Private","title":"Diagnostics","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.Diagnostics]\nPublic = false","category":"page"},{"location":"library/internals/#InitialConditions","page":"Private","title":"InitialConditions","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.InitialConditions]\nPublic = false","category":"page"},{"location":"library/internals/#DataWrangling","page":"Private","title":"DataWrangling","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.DataWrangling]\nPublic = false","category":"page"},{"location":"library/internals/#ClimaOcean.DataWrangling.NearestNeighborInpainting","page":"Private","title":"ClimaOcean.DataWrangling.NearestNeighborInpainting","text":"NearestNeighborInpainting{M}\n\nA structure representing the nearest neighbor inpainting algorithm, where a missing value is substituted with the average of the surrounding valid values. This process is repeated a maximum of maxiter times or until the field is completely inpainted.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#ClimaOcean.DataWrangling.continue_downwards!-Tuple{Any, Any}","page":"Private","title":"ClimaOcean.DataWrangling.continue_downwards!","text":"continue_downwards!(field, mask)\n\nContinue downwards a field with missing values within mask. Cells where mask[i, k, k] == false will be preserved.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ClimaOcean.DataWrangling.download_progress-Tuple{Any, Any}","page":"Private","title":"ClimaOcean.DataWrangling.download_progress","text":"download_progress(total, now; filename=\"\")\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ClimaOcean.DataWrangling.inpaint_mask!-Tuple{Any, Any}","page":"Private","title":"ClimaOcean.DataWrangling.inpaint_mask!","text":"inpaint_mask!(field, mask; max_iter = Inf)\n\nInpaint field within mask, using values outside mask. In other words, regions where mask[i, j, k] == 1 is inpainted and regions where mask[i, j, k] == 0 are preserved.\n\nArguments\n\nfield: Field to be inpainted.\nmask: Boolean-valued Field, values where         mask[i, j, k] == true are inpainted.\ninpainting: The inpainting algorithm to use. For the moment, the only option is NearestNeighborInpainting(maxiter),                where an average of the valid surrounding values is used maxiter times.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ClimaOcean.DataWrangling.propagate_horizontally!","page":"Private","title":"ClimaOcean.DataWrangling.propagate_horizontally!","text":"propagate_horizontally!(inpainting, field, mask [, tmp_field=deepcopy(field)])\n\nHorizontally propagate the values of field into the mask. In other words, cells where mask[i, j, k] == false are preserved, and cells where mask[i, j, k] == true are painted over.\n\nThe first argument inpainting is the inpainting algorithm to use in the _propagate_field! step.\n\n\n\n\n\n","category":"function"},{"location":"library/internals/#ECCO","page":"Private","title":"ECCO","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.ECCO]\nPublic = false","category":"page"},{"location":"library/internals/#ClimaOcean.DataWrangling.ECCO.ECCONetCDFBackend-Tuple{Any, Any}","page":"Private","title":"ClimaOcean.DataWrangling.ECCO.ECCONetCDFBackend","text":"ECCONetCDFBackend(length; on_native_grid = false, inpainting = NearestNeighborInpainting(Inf))\n\nRepresent an ECCO FieldTimeSeries backed by ECCO native netCDF files. Each time instance is stored in an individual file.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ClimaOcean.DataWrangling.ECCO.ECCO_field_time_series-Tuple{ECCOMetadata}","page":"Private","title":"ClimaOcean.DataWrangling.ECCO.ECCO_field_time_series","text":"ECCO_field_time_series(metadata::ECCOMetadata;\n                       grid = nothing,\n                       architecture = isnothing(grid) ? CPU() : architecture(grid),\n                       time_indices_in_memory = 2,\n                       time_indexing = Cyclical(),\n                       inpainting_iterations = prod(size(metadata)),\n\nCreate a field time series object for ECCO data.\n\nArguments\n\nmetadata: ECCOMetadata containing information about the ECCO dataset.\n\nKeyword Arguments\n\ngrid: where ECCO data is interpolated. If nothing, the native ECCO grid is used.\narchitecture: where data is stored. Should only be set if isnothing(grid).\ntime_indices_in_memory: The number of time indices to keep in memory. Default: 2.\ntime_indexing: The time indexing scheme to use. Default: Cyclical().\ninpainting: The inpainting algorithm to use for ECCO interpolation.               The only option is NearestNeighborInpainting(maxiter),                where an average of the valid surrounding values is used maxiter times.\ncache_inpainted_data: If true, the data is cached to disk after inpainting for later retrieving.                          Default: true.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ClimaOcean.DataWrangling.ECCO.ECCO_times-Tuple{Any}","page":"Private","title":"ClimaOcean.DataWrangling.ECCO.ECCO_times","text":"ECCO_times(metadata; start_time = metadata.dates[1])\n\nExtract the time values from the given metadata and calculates the time difference from the start time.\n\nArguments\n\nmetadata: The metadata containing the date information.\nstart_time: The start time for calculating the time difference. Defaults to the first date in the metadata.\n\nReturns\n\nAn array of time differences in seconds.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#ClimaOcean.DataWrangling.ECCO.download_dataset-Tuple{ECCOMetadata}","page":"Private","title":"ClimaOcean.DataWrangling.ECCO.download_dataset","text":"download_dataset(metadata::ECCOMetadata; url = urls(metadata))\n\nDownload the dataset specified by ECCOMetadata. If ECCOMetadata.dates is a single date,  the dataset is downloaded directly. If ECCOMetadata.dates is a vector of dates, each date is downloaded individually. The data download requires a username and password to be provided in the ECCO_USERNAME and ECCO_PASSWORD environment variables. This can be done by exporting the environment variables in the shell before running the script, or by launching julia with \n\nECCO_USERNAME=myusername ECCO_PASSWORD=mypassword julia \n\nArguments\n\nmetadata::ECCOMetadata: The metadata specifying the dataset to be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#Bathymetry","page":"Private","title":"Bathymetry","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.Bathymetry]\nPublic = false","category":"page"},{"location":"library/internals/#ClimaOcean.Bathymetry.remove_minor_basins!-Tuple{Oceananigans.Fields.Field, Any}","page":"Private","title":"ClimaOcean.Bathymetry.remove_minor_basins!","text":"remove_minor_basins!(z_data, keep_major_basins)\n\nRemove independent basins from the bathymetry data stored in z_data by identifying connected regions below sea level. Basins are removed from smallest to largest until only keep_major_basins remain.\n\nArguments\n\nz_data: A 2D array representing the bathymetry data.\nkeep_major_basins: The maximum number of connected regions to keep.                       Default is Inf, which means all connected regions are kept.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#VerticalGrids","page":"Private","title":"VerticalGrids","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.VerticalGrids]\nPrivate = false","category":"page"},{"location":"library/internals/#ClimaOcean.VerticalGrids.stretched_vertical_faces-Tuple{}","page":"Private","title":"ClimaOcean.VerticalGrids.stretched_vertical_faces","text":"stretched_vertical_faces(; surface_layer_Δz = 5.0,\n                           surface_layer_height = 100.0,\n                           constant_bottom_spacing_depth = Inf,\n                           maximum_Δz = Inf,\n                           stretching = PowerLawStretching(1.02),\n                           rounding_digits = 1,\n                           depth = 5000)\n\nReturn an array of cell interfaces with surface_layer_Δz spacing in a surface layer of height surface_layer_height, and stretched according to the function stretching(Δz_above, z_above) down to depth. The interfaces extends from Lz = -z[1] to 0 = z[end], where Lz ≥ depth.\n\nThe grid spacing Δz is limited to be less than maximum_Δz. The grid is also uniformly-spaced below constant_bottom_spacing_depth.\n\nrounding_digits controls the accuracy with which the grid face positions are saved.\n\n\n\n\n\n","category":"method"},{"location":"library/internals/#OceanSeaIceModels","page":"Private","title":"OceanSeaIceModels","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.OceanSeaIceModels]\nPrivate = false","category":"page"},{"location":"library/internals/#ClimaOcean.OceanSeaIceModels.FreezingLimitedOceanTemperature","page":"Private","title":"ClimaOcean.OceanSeaIceModels.FreezingLimitedOceanTemperature","text":"FreezingLimitedOceanTemperature(FT::DataType) = FreezingLimitedOceanTemperature(LinearLiquidus(FT))\n\nThe minimal possible sea ice representation, providing an \"Insulating layer\" on the surface and clipping the  temperature below to the freezing point. Not really a `model'' per se, however,  it is the most simple way to make sure that temperature does not dip below freezing.  All fluxes are shut down when the surface is below theT < Tₘ` except for heating to allow temperature to increase.\n\nthe melting temperature is a function of salinity and is controlled by the liquidus.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#CrossRealFluxes","page":"Private","title":"CrossRealFluxes","text":"","category":"section"},{"location":"library/internals/","page":"Private","title":"Private","text":"Modules = [ClimaOcean.OceanSeaIceModels.CrossRealmFluxes]\nPrivate = false","category":"page"},{"location":"library/internals/#ClimaOcean.OceanSeaIceModels.CrossRealmFluxes.LatitudeDependentAlbedo","page":"Private","title":"ClimaOcean.OceanSeaIceModels.CrossRealmFluxes.LatitudeDependentAlbedo","text":"LatitudeDependentAlbedo([FT::DataType=Float64]; diffuse = 0.069, direct = 0.011)\n\nConstructs a LatitudeDependentAlbedo object. The albedo of the ocean surface is assumed to be a function of the latitude, obeying the following formula (Large and Yeager, 2009):\n\nα(φ) = α.diffuse - α.direct * cos(2φ)\n\nwhere φ is the latitude, α.diffuse is the diffuse albedo, and α.direct is the direct albedo.\n\nArguments\n\nFT::DataType: The data type of the albedo values. Default is Float64.\n\nKeyword Arguments\n\ndiffuse: The diffuse albedo value. Default is 0.069.\ndirect: The direct albedo value. Default is 0.011.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#ClimaOcean.OceanSeaIceModels.CrossRealmFluxes.Radiation","page":"Private","title":"ClimaOcean.OceanSeaIceModels.CrossRealmFluxes.Radiation","text":"Radiation([arch = CPU(), FT=Float64];\n          ocean_emissivity = 0.97,\n          sea_ice_emissivity = 1.0,\n          ocean_albedo = LatitudeDependentAlbedo(FT),\n          sea_ice_albedo = 0.7,\n          stefan_boltzmann_constant = 5.67e-8)\n\nConstructs a Radiation object that represents the radiation properties of the ocean and sea ice.\n\nArguments\n\narch: The architecture of the system. Default: CPU().\nFT: The floating-point type to use. Default: Float64.\n\nKeyword Arguments\n\nocean_emissivity: The emissivity of the ocean surface. Default: 0.97.\nsea_ice_emissivity: The emissivity of the sea ice surface. Default: 1.0.\nocean_albedo: The albedo of the ocean surface. Default: LatitudeDependentAlbedo(FT).\nsea_ice_albedo: The albedo of the sea ice surface. Default: 0.7.\nstefan_boltzmann_constant: The Stefan-Boltzmann constant. Default: 5.67e-8.\n\n\n\n\n\n","category":"type"},{"location":"library/internals/#ClimaOcean.OceanSeaIceModels.CrossRealmFluxes.SimilarityTheoryTurbulentFluxes","page":"Private","title":"ClimaOcean.OceanSeaIceModels.CrossRealmFluxes.SimilarityTheoryTurbulentFluxes","text":"SimilarityTheoryTurbulentFluxes(FT::DataType = Float64;\n                                gravitational_acceleration = default_gravitational_acceleration,\n                                von_karman_constant = convert(FT, 0.4),\n                                turbulent_prandtl_number = convert(FT, 1),\n                                gustiness_parameter = convert(FT, 6.5),\n                                stability_functions = default_stability_functions(FT),\n                                thermodynamics_parameters = PATP(FT),\n                                water_vapor_saturation = ClasiusClapyeronSaturation(),\n                                water_mole_fraction = convert(FT, 0.98),\n                                roughness_lengths = default_roughness_lengths(FT),\n                                similarity_profile_type = LogarithmicSimilarityProfile(),\n                                bulk_velocity = RelativeVelocity(),\n                                tolerance = 1e-8,\n                                maxiter = 100,\n                                fields = nothing)\n\nSimilarityTheoryTurbulentFluxes contains parameters and settings to calculate sea-air turbulent fluxes using Monin-Obukhov similarity theory.\n\nKeyword Arguments\n\ngravitational_acceleration: The gravitational acceleration. Default: default_gravitational_acceleration.\nvon_karman_constant: The von Karman constant. Default: 0.4.\nturbulent_prandtl_number: The turbulent Prandtl number. Default: 1.\ngustiness_parameter: The gustiness parameter that accounts for low wind speed areas. Default: 6.5.\nstability_functions: The stability functions. Default: default_stability_functions(FT) that follow the                         formulation of Edson et al. (2013).\nthermodynamics_parameters: The thermodynamics parameters used to calculate atmospheric stability and                              saturation pressure. Default: PATP(FT), alias for PrescribedAtmosphereThermodynamicsParameters.\nwater_vapor_saturation: The water vapor saturation law. Default: ClasiusClapyeronSaturation() that follows the                            Clasius-Clapyeron pressure formulation.\nwater_mole_fraction: The water mole fraction used to calculate the seawater_saturation_specific_humidity.                         Default: 0.98, the rest is assumed to be other substances such as chlorine, sodium sulfide, and magnesium.\nroughness_lengths: The roughness lengths used to calculate the characteristic scales for momentum, temperature and                       water vapor. Default: default_roughness_lengths(FT), formulation taken from Edson et al (2013).\nsimilarity_profile_type: The type of similarity profile used to relate the atmospheric state to the                             surface fluxes / characteristic scales.\nbulk_velocity: The velocity used to calculate the characteristic scales. Default: RelativeVelocity() (difference between                  atmospheric and oceanic speed).\ntolerance: The tolerance for convergence. Default: 1e-8.\nmaxiter: The maximum number of iterations. Default: 100.\nfields: The fields to calculate. Default: nothing.\n\n\n\n\n\n","category":"type"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"EditURL = \"../../../examples/generate_bathymetry.jl\"","category":"page"},{"location":"literated/generate_bathymetry/#Generate-bathymetry-data-for-the-Mediterranean-Sea","page":"Generate bathymetry","title":"Generate bathymetry data for the Mediterranean Sea","text":"","category":"section"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"This example shows how to configure an Immersed boundary grid with realistic bathymetry using ClimaOcean.jl by generating the bathymetry data for the Mediterranean Sea.","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"For this example, we need Oceananigans for the LatitudeLongitudeGrid and Field utilities, ClimaOcean to donwload and regrid the bathymetry, and CairoMakie to visualize the grid.","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"using ClimaOcean\nusing Oceananigans\nusing CairoMakie","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"We start by defining a gridded domain for the Mediterranean Sea using the LatitudeLongitudeGrid from Oceananigans.","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"The Mediterranean sea is positioned roughly between 28ᵒ and 48ᵒ latitude and 0ᵒ and 42ᵒ longitude. We define a grid in this region and to have a reasonable resolution, we set a grid resolution to 1/25ᵒ in both latitude and longitude directions.","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"latitude_range = (28, 48)\nlongitude_range = (0, 42)\n\nNφ = 25 * (latitude_range[2] - latitude_range[1])\nNλ = 25 * (longitude_range[2] - longitude_range[1])\n\ngrid = LatitudeLongitudeGrid(size = (Nλ, Nφ, 1),\n                             latitude = latitude_range,\n                             longitude = longitude_range,\n                             z = (0, 1),\n                             halo = (7, 7, 1))","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"1050×500×1 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on Oceananigans.Architectures.CPU with 7×7×1 halo and with precomputed metrics\n├── longitude: Bounded  λ ∈ [0.0, 42.0]  regularly spaced with Δλ=0.04\n├── latitude:  Bounded  φ ∈ [28.0, 48.0] regularly spaced with Δφ=0.04\n└── z:         Bounded  z ∈ [0.0, 1.0]   regularly spaced with Δz=1.0","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"Next, we generate the bathymetry data for the Mediterranean Sea using the regrid_bathymetry function from ClimaOcean. The function downloads the bathymetry data from the ETOPO1 dataset, regrids it to the provided grid, and returns the bathymetry field. The three different regidding procedures below demonstrate the effect of different parameters on the generated bathymetry:","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"h_rough shows the output of the function with default parameters, which means only one interpolation passes and no restrictions on connected regions.\nh_smooth shows the output of the function with 40 interpolation passes, which results  in a smoother bathymetry.\nh_no_connected_regions shows the output of the function with connected_regions_allowed = 0, which  means that the function does not allow connected regions in the bathymetry  (e.g., lakes)  and fills them with land.","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"h_rough = regrid_bathymetry(grid)\nh_smooth = regrid_bathymetry(grid; interpolation_passes = 40)\nh_one_basin = regrid_bathymetry(grid; major_basins = 1)","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"Finally, we visualize the generated bathymetry data for the Mediterranean Sea using CairoMakie.","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"land_smooth = interior(h_smooth) .>= 0\ninterior(h_smooth)[land_smooth] .= NaN\n\nland_rough = interior(h_rough) .>= 0\ninterior(h_rough)[land_rough] .= NaN\n\nland_one_basin = interior(h_one_basin) .>= 0\ninterior(h_one_basin)[land_one_basin] .= NaN\n\nfig = Figure(size=(850, 1150))\n\nax = Axis(fig[1, 1], title = \"Rough bathymetry\", xlabel = \"Longitude\", ylabel = \"Latitude\")\nhm = heatmap!(ax, h_rough, nan_color=:lightgray, colormap = Reverse(:deep))\n\nax = Axis(fig[2, 1], title = \"Smooth bathymetry\", xlabel = \"Longitude\", ylabel = \"Latitude\")\nhm = heatmap!(ax, h_smooth, nan_color=:lightgray, colormap = Reverse(:deep))\n\nax = Axis(fig[3, 1], title = \"Bathymetry with only one basin\", xlabel = \"Longitude\", ylabel = \"Latitude\")\nhm = heatmap!(ax, h_one_basin, nan_color=:lightgray, colormap = Reverse(:deep))\n\ncb = Colorbar(fig[1:3, 2], hm, height = Relative(3/4), label = \"Depth (m)\")\n\nsave(\"different_bottom_heights.png\", fig)","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"(Image: )","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"","category":"page"},{"location":"literated/generate_bathymetry/","page":"Generate bathymetry","title":"Generate bathymetry","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#ClimaOcean.jl","page":"Home","title":"ClimaOcean.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"🌎 Realistic ocean-only and coupled ocean + sea-ice simulations driven by prescribed atmospheres and based on Oceananigans and ClimaSeaIce.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaOcean implements a framework for driving coupled ocean and sea ice simulations with prescribed atmospheres, using bulk formula to compute atmosphere-ocean, atmosphere-ice, and ocean-ice fluxes of heat, momentum, and freshwater. ClimaOcean builds off the Oceananigans framework, which provides tools for gridded finite volume computations on CPUs and GPUs and building ocean-flavored fluid dynamics simulations. ClimaSeaIce, which provides software for both stand-alone and coupled sea ice simulations, is also built with Oceananigans.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaOcean's core abstractions are OceanSeaIceModel which encapsulates the ocean simulation, sea ice simulation, prescribed atmospheric state, atmospheric thermodynamic parameters, and parameterizations that define how the three communicate. ClimaOcean also implements ocean_simulation, a utility for building realistic, hydrostatic ocean simulations with Oceananigans ensuring compatibility with OceanSeaIceModel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ClimaOcean is written in Julia by the Climate Modeling Alliance and heroic external collaborators.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClimaOcean is a registered Julia package. So to install it,","category":"page"},{"location":"","page":"Home","title":"Home","text":"Download Julia.\nLaunch Julia and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"ClimaOcean\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"compat: Julia 1.9 is required\nClimaOcean requires Julia 1.9 or later.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following script implements a near-global ocean simulation initialized from the ECCO state estimate and coupled to a prescribed atmosphere derived from the JRA55-do reanalysis:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Oceananigans\nusing Oceananigans.Units\nusing Dates, CFTime\nimport ClimaOcean\n\narch = GPU()\ngrid = LatitudeLongitudeGrid(arch,\n                             size = (1440, 560, 10),\n                             halo = (7, 7, 7),\n                             longitude = (0, 360),\n                             latitude = (-70, 70),\n                             z = (-3000, 0))\n\nbathymetry = ClimaOcean.regrid_bathymetry(grid) # builds gridded bathymetry based on ETOPO1\ngrid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry))\n\n# Build an ocean simulation initialized to the ECCO state estimate on Jan 1, 1993\nocean = ClimaOcean.ocean_simulation(grid)\ndate  = DateTimeProlepticGregorian(1993, 1, 1)\nset!(ocean.model, T = ClimaOcean.ECCOMetadata(:temperature; date),\n                  S = ClimaOcean.ECCOMetadata(:salinity; date))\n\n# Build and run an OceanSeaIceModel (with no sea ice component) forced by JRA55 reanalysis\natmosphere = ClimaOcean.JRA55_prescribed_atmosphere(arch)\ncoupled_model = ClimaOcean.OceanSeaIceModel(ocean; atmosphere)\nsimulation = Simulation(coupled_model, Δt=5minutes, stop_time=30days)\nrun!(simulation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The simulation above achieves approximately 8 simulated years per day of wall time on an Nvidia H100 GPU.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can leverage Oceananigans features to plot the surface speed at the end of the simulation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u, v, w = ocean.model.velocities\nspeed = Field(sqrt(u^2 + v^2))\ncompute!(speed)\n\nusing GLMakie\nheatmap(view(speed, :, :, ocean.model.grid.Nz), colorrange=(0, 0.5), colormap=:magma, nan_color=:lightgray)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image)","category":"page"},{"location":"library/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Documentation for ClimaOcean.jl's public interface.","category":"page"},{"location":"library/public/","page":"Public","title":"Public","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"library/public/#ClimaOcean","page":"Public","title":"ClimaOcean","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ClimaOcean]\nPrivate = false","category":"page"},{"location":"library/public/#ClimaOcean.ClimaOcean","page":"Public","title":"ClimaOcean.ClimaOcean","text":"<!– Title –> <h1 align=\"center\">   ClimaOcean.jl </h1>\n\n<!– description –> <p align=\"center\">   <strong>🌎 A framework for realistic ocean-only and coupled ocean + sea-ice simulations driven by prescribed atmospheres and based on <a href=https://github.com/CliMA/Oceananigans.jl>Oceananigans</a> and <a href=https://github.com/CliMA/ClimaSeaIce.jl>ClimaSeaIce</a></strong>.  </p>\n\n\n\n(Image: DOI) (Image: Build status) (Image: Documentation) (Image: Documentation)\n\nInstallation\n\nClimaOcean is a registered package. To install from a Julia REPL:\n\njulia> using Pkg\n\njulia> Pkg.add(\"ClimaOcean\")\n\njulia> Pkg.instantiate()\n\nUse Pkg.add(\"url=https://github.com/CliMA/ClimaOcean.jl.git\", rev=\"main\") to install the latest version of ClimaOcean. For more information, see the documentation for Pkg.jl.\n\nWhy? What's the difference between ClimaOcean and Oceananigans?\n\nOceananigans is a general-purpose library for ocean-flavored fluid dynamics.  ClimaOcean implements a framework for driving realistic Oceananigans simulations with prescribed atmospheres, and coupling them to prognostic sea ice simulations.\n\nA core abstraction: ClimaOcean.OceanSeaIceModel\n\nOur system for realistic modeling is anchored by ClimaOcean.OceanSeaIceModel, which encapsulates the ocean simulation, sea ice simulation, prescribed atmospheric state, and specifies how the three communicate. To illustrate how OceanSeaIceModel works we set up a simulation on a grid with 10 vertical levels and 1/4-degree horizontal resolution:\n\nusing Oceananigans\nusing Oceananigans.Units\nusing Dates, CFTime\nimport ClimaOcean\n\narch = GPU()\ngrid = LatitudeLongitudeGrid(arch,\n                             size = (1440, 560, 10),\n                             halo = (7, 7, 7),\n                             longitude = (0, 360),\n                             latitude = (-70, 70),\n                             z = (-3000, 0))\n\nbathymetry = ClimaOcean.regrid_bathymetry(grid) # builds gridded bathymetry based on ETOPO1\ngrid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry))\n\n# Build an ocean simulation initialized to the ECCO state estimate on Jan 1, 1993\nocean = ClimaOcean.ocean_simulation(grid)\ndate  = DateTimeProlepticGregorian(1993, 1, 1)\nset!(ocean.model, T = ClimaOcean.ECCOMetadata(:temperature; date),\n                  S = ClimaOcean.ECCOMetadata(:salinity; date))\n\n# Build and run an OceanSeaIceModel (with no sea ice component) forced by JRA55 reanalysis\natmosphere = ClimaOcean.JRA55_prescribed_atmosphere(arch)\ncoupled_model = ClimaOcean.OceanSeaIceModel(ocean; atmosphere)\nsimulation = Simulation(coupled_model, Δt=5minutes, stop_time=30days)\nrun!(simulation)\n\nThe simulation above achieves approximately 8 simulated years per day of wall time on an Nvidia H100 GPU.\n\nSince ocean.model is an Oceananigans.HydrostaticFreeSurfaceModel, we can leverage Oceananigans features in our scripts. For example, to plot the surface speed at the end of the simulation we write\n\nu, v, w = ocean.model.velocities\nspeed = Field(sqrt(u^2 + v^2))\ncompute!(speed)\n\nusing GLMakie\nheatmap(view(speed, :, :, ocean.model.grid.Nz), colorrange=(0, 0.5), colormap=:magma, nan_color=:lightgray)\n\nwhich produces\n\n(Image: image)\n\nAdditional features: a utility for ocean_simulations and data wrangling\n\nA second core abstraction in ClimaOcean is ocean_simulation. ocean_simulation configures an Oceananigans model for realistic simulations including temperature and salinity, the TEOS-10 equation of state, boundary conditions to store computed air-sea fluxes, the automatically-calibrated turbulence closure CATKEVerticalDiffusivity, and the WENOVectorInvariant advection scheme for mesoscale-turbulence-resolving simulations.\n\nClimaOcean also provides convenience features for wrangling datasets of bathymetry, ocean temperature, salinity, ocean velocity fields, and prescribed atmospheric states.\n\nClimaOcean is built on top of Oceananigans and ClimaSeaIce, so it's important that ClimaOcean users become proficient with Oceananigans. Note that though ClimaOcean is currently focused on hydrostatic modeling with Oceananigans.HydrostaticFreeSurfaceModel, realistic nonhydrostatic modeling is also within the scope of this package.\n\n\n\n\n\n","category":"module"},{"location":"library/public/#ClimaOcean.@distribute-Tuple{Any}","page":"Public","title":"ClimaOcean.@distribute","text":"@distribute for i in iterable\n    ...\nend\n\nDistribute a for loop among different ranks\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#ClimaOcean.@handshake-Tuple{Any}","page":"Public","title":"ClimaOcean.@handshake","text":"@handshake exs...\n\nperform exs on all ranks, but only one rank at a time, where ranks r2 > r1 wait for rank r1 to finish before executing exs\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#ClimaOcean.@onrank-Tuple{Any}","page":"Public","title":"ClimaOcean.@onrank","text":"@onrank rank, exs...\n\nPerform exp only on rank rank Other ranks will wait for the root rank to finish before continuing. The expression is run anyways if MPI in not initialized\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#ClimaOcean.@root-Tuple{Any}","page":"Public","title":"ClimaOcean.@root","text":"@root exs...\n\nPerform exs only on rank 0, otherwise know as \"root\" rank. Other ranks will wait for the root rank to finish before continuing\n\n\n\n\n\n","category":"macro"},{"location":"library/public/#Diagnostics","page":"Public","title":"Diagnostics","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ClimaOcean.Diagnostics]\nPrivate = false","category":"page"},{"location":"library/public/#ClimaOcean.Diagnostics.MixedLayerDepthField-Tuple{Any, Any, Any}","page":"Public","title":"ClimaOcean.Diagnostics.MixedLayerDepthField","text":"MixedLayerDepthField(grid, tracers, buoyancy_model; Δb = 3e-4, field_kw...)\n\nReturn a reduced Field{Center, Center, Nothing} that represents mixed layer depth for model, based on a buoyancy differential criterion. The mixed layer depth is defined as the depth h for which\n\nb(z=0) - b(z=-h) = Δb\n\nThis criterion is solved by integrating downwards and linearly interpolating to find h, assuming that b decreases with depth.\n\nKeyword arguments\n\nΔb: Buoyancy differential used to calculate mixed layer depth\nfield_kw: Keyword arguments passed to Field.\n\nExample\n\nh = MixedLayerDepth(model)\ncompute!(h) # compute mixed layer depth\n\n\n\n\n\n","category":"method"},{"location":"library/public/#InitialConditions","page":"Public","title":"InitialConditions","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ClimaOcean.InitialConditions]\nPrivate = false","category":"page"},{"location":"library/public/#DataWrangling","page":"Public","title":"DataWrangling","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ClimaOcean.DataWrangling]\nPrivate = false","category":"page"},{"location":"library/public/#ECCO","page":"Public","title":"ECCO","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ClimaOcean.ECCO]\nPrivate = false","category":"page"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.ECCOMetadata","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.ECCOMetadata","text":"struct ECCOMetadata{D, V}\n\nMetadata information for an ECCO dataset:\n\nname: The name of the dataset.\ndates: The dates of the dataset, in an AbstractCFDateTime format.\nversion: The version of the dataset, could be ECCO2Monthly, ECCO2Daily, or ECCO4Monthly.\ndir: The directory where the dataset is stored.\n\n\n\n\n\n","category":"type"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.ECCOMetadata-Tuple{Symbol}","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.ECCOMetadata","text":"ECCOMetadata(name::Symbol; \n             dates = DateTimeProlepticGregorian(1993, 1, 1),\n             version = ECCO4Monthly(),\n             dir = download_ECCO_cache)\n\nConstruct an ECCOMetadata object with the specified parameters.\n\nArguments\n\nname::Symbol: The name of the metadata.\n\nKeyword Arguments\n\ndates: The date(s) of the metadata. Note this can either be a single date,          representing a snapshot, or a range of dates, representing a time-series.          Default: DateTimeProlepticGregorian(1993, 1, 1).\nversion: The data version. Supported versions are ECCO2Monthly(), ECCO2Daily(),            or ECCO4Monthly().\ndir: The directory of the data file. Default: download_ECCO_cache.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.ECCORestoring-Tuple{Oceananigans.Architectures.AbstractArchitecture, Symbol}","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.ECCORestoring","text":"ECCORestoring([arch=CPU(),]\n              variable_name::Symbol;\n              version=ECCO4Monthly(),\n              dates=all_ECCO_dates(version),\n              dates = all_ECCO_dates(version), \n              time_indices_in_memory = 2, \n              time_indexing = Cyclical(),\n              mask = 1,\n              rate = 1,\n              grid = nothing,\n              inpainting = NearestNeighborInpainting(prod(size(metadata))),\n              cache_inpainted_data = true)\n\nCreate a forcing term that restores to values stored in an ECCO field time series. The restoring is applied as a forcing on the right hand side of the evolution equations calculated as\n\nF = mask ⋅ rate ⋅ (ECCO_variable - simulation_variable[i, j, k])\n\nwhere ECCO_variable is linearly interpolated in space and time from the ECCO dataset of choice to the  simulation grid and time.\n\nArguments\n\narch: The architecture. Typically CPU() or GPU(). Default: CPU().\nvariable_name: The name of the variable to restore. Choices include:\n:temperature,\n:salinity,\n:u_velocity,\n:v_velocity,\n:sea_ice_thickness,\n:sea_ice_area_fraction.\n\nKeyword Arguments\n\nversion: The version of the ECCO dataset. Default: ECCO4Monthly().\ndates: The dates to use for the ECCO dataset. Default: all_ECCO_dates(version).\ntime_indices_in_memory: The number of time indices to keep in memory; trade-off between performance                           and memory footprint.    \ntime_indexing: The time indexing scheme for the field time series≥\nmask: The mask value. Can be a function of (x, y, z, time), an array, or a number.\nrate: The restoring rate, i.e., the inverse of the restoring timescale (in s⁻¹).\ntime_indices_in_memory: how many time instances are loaded in memory; the remaining are loaded lazily.\ninpainting: inpainting algorithm, see inpaint_mask!. Default: NearestNeighborInpainting(Inf).\ngrid: If isnothing(grid), ECCO data is interpolated on-the-fly to the simulation grid.         If !isnothing(grid), ECCO data is pre-interpolated to grid.         Default: nothing.\ncache_inpainted_data: If true, the data is cached to disk after inpainting for later retrieving.                          Default: true.\n\nIt is possible to also pass an ECCOMetadata type as the first argument without the need for the  variable_name argument and the version and dates keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.LinearlyTaperedPolarMask-Tuple{}","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.LinearlyTaperedPolarMask","text":"LinearlyTaperedPolarMask(; northern = (70,   75),\n                           southern = (-75, -70),\n                           z = (-20, 0))\n\nBuild a mask that is linearly tapered in latitude between the northern and southern edges. The mask is constant in depth between the z and equals zero everywhere else. The mask is limited to lie between (0, 1). The mask has the following functional form:\n\nn = 1 / (northern[2] - northern[1]) * (φ - northern[1])\ns = 1 / (southern[1] - southern[2]) * (φ - southern[2])\n\nvalid_depth = (z[1] < z < z[2])\n\nmask = valid_depth ? clamp(max(n, s), 0, 1) : 0\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.ECCO_field-Tuple{ECCOMetadata}","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.ECCO_field","text":"ECCO_field(metadata::ECCOMetadata;\n           architecture = CPU(),\n           inpainting = nothing,\n           mask = nothing,\n           horizontal_halo = (7, 7),\n           cache_inpainted_data = false)\n\nReturn a Field on architecture described by ECCOMetadata with horizontal_halo size. If not nothing, the inpainting method is used to fill the cells within the specified mask. mask is set to ECCO_mask for non-nothing inpainting.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.ECCO_immersed_grid","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.ECCO_immersed_grid","text":"ECCO_immersed_grid(metadata, architecture = CPU())\n\nCompute the ImmersedBoundaryGrid for metadata with a bottom height field that is defined  by the first non-missing value from the bottom up.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#ClimaOcean.DataWrangling.ECCO.ECCO_mask","page":"Public","title":"ClimaOcean.DataWrangling.ECCO.ECCO_mask","text":"ECCO_mask(architecture = CPU(); minimum_value = Float32(-1e5))\n\nA boolean field where true represents a missing value in the ECCO dataset.\n\n\n\n\n\n","category":"function"},{"location":"library/public/#Bathymetry","page":"Public","title":"Bathymetry","text":"","category":"section"},{"location":"library/public/","page":"Public","title":"Public","text":"Modules = [ClimaOcean.Bathymetry]\nPrivate = false","category":"page"},{"location":"library/public/#ClimaOcean.Bathymetry.regrid_bathymetry-Tuple{Any}","page":"Public","title":"ClimaOcean.Bathymetry.regrid_bathymetry","text":"regrid_bathymetry(target_grid;\n                  url = \"https://www.ngdc.noaa.gov/thredds/fileServer/global/ETOPO2022/60s/60s_surface_elev_netcdf\", \n                  height_above_water = <none>,\n                  minimum_depth = 0,\n                  dir = download_cache,\n                  filename = \"ETOPO_2022_v1_60s_N90W180_surface.nc\")\n\nRegrid bathymetry associated with the NetCDF file at path = joinpath(dir, filename) to target_grid. If path does not exist, then a download is attempted from joinpath(url, filename).\n\nArguments\n\ntarget_grid: grid to interpolate onto\n\nKeyword Arguments\n\nheight_above_water: limits the maximum height of above-water topography (where h > 0). If                       nothing the original topography is retained\nminimum_depth: minimum depth for the shallow regions, defined as a positive value.                   h > - minimum_depth will be considered land\ndir: directory of the bathymetry-containing file\nfilename: file containing bathymetric data. Must be netcdf with fields:             (1) lat vector of latitude nodes             (2) lon vector of longitude nodes             (3) z matrix of depth values\ninterpolation_passes: regridding/interpolation passes. The bathymetry is interpolated in                         interpolation_passes - 1 intermediate steps. With more steps the                          final bathymetry will be smoother.\nExample: interpolating from a 400x200 grid to a 100x100 grid in 4 passes involves:\n400x200 → 325x175\n325x175 → 250x150\n250x150 → 175x125\n175x125 → 100x100\nIf coarsening the original grid, linear interpolation in passes is equivalent to applying a smoothing filter, with more passes increasing the strength of the filter. If refining the original grid, additional passes will not help and no intermediate steps will be performed.\nmajor_basins: Number of \"independent major basins\", or fluid regions fully encompassed by land,                 that are retained by remove_minor_basins!. Basins are removed by order of size:                 the smallest basins are removed first. major_basins=1 will retain only the largest basin.                 Default: Inf, which does not remove any basins.\n\n\n\n\n\n","category":"method"},{"location":"library/public/#ClimaOcean.Bathymetry.retrieve_bathymetry-Tuple{Any, Any}","page":"Public","title":"ClimaOcean.Bathymetry.retrieve_bathymetry","text":"retrieve_bathymetry(grid, filename; kw...)\n\nRetrieve the bathymetry data from a file or generate it using a grid and save it to a file.\n\nArguments\n\ngrid: The grid used to generate the bathymetry data.\nfilename: The name of the file to read or save the bathymetry data.\nkw...: Additional keyword arguments.\n\nReturns\n\nbottom_height: The retrieved or generated bathymetry data.\n\nIf the specified file exists, the function reads the bathymetry data from the file.  Otherwise, it generates the bathymetry data using the provided grid and saves it to the file before returning it.\n\n\n\n\n\n","category":"method"}]
}
