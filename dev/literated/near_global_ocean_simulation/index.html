<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Near-global Ocean simulation · ClimaOcean.jl</title><meta name="title" content="Near-global Ocean simulation · ClimaOcean.jl"/><meta property="og:title" content="Near-global Ocean simulation · ClimaOcean.jl"/><meta property="twitter:title" content="Near-global Ocean simulation · ClimaOcean.jl"/><meta name="description" content="Documentation for ClimaOcean.jl."/><meta property="og:description" content="Documentation for ClimaOcean.jl."/><meta property="twitter:description" content="Documentation for ClimaOcean.jl."/><meta property="og:url" content="https://clima.github.io/ClimaOceanDocumentation/dev/literated/near_global_ocean_simulation/"/><meta property="twitter:url" content="https://clima.github.io/ClimaOceanDocumentation/dev/literated/near_global_ocean_simulation/"/><link rel="canonical" href="https://clima.github.io/ClimaOceanDocumentation/dev/literated/near_global_ocean_simulation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ClimaOcean.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../single_column_os_papa_simulation/">Single-column simulation</a></li><li><a class="tocitem" href="../one_degree_simulation/">One-degree Ocean simulation</a></li><li class="is-active"><a class="tocitem" href>Near-global Ocean simulation</a><ul class="internal"><li><a class="tocitem" href="#Initial-setup-with-package-imports"><span>Initial setup with package imports</span></a></li><li><a class="tocitem" href="#The-coupled-simulation"><span>The coupled simulation</span></a></li><li><a class="tocitem" href="#A-pretty-movie"><span>A pretty movie</span></a></li></ul></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../../library/outline/">Contents</a></li><li><a class="tocitem" href="../../library/public/">Public</a></li><li><a class="tocitem" href="../../library/internals/">Private</a></li><li><a class="tocitem" href="../../library/function_index/">Function index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Near-global Ocean simulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Near-global Ocean simulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaOcean.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/CliMA/ClimaOcean.jl/blob/main/examples/near_global_ocean_simulation.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Near-global-ocean-simulation"><a class="docs-heading-anchor" href="#Near-global-ocean-simulation">Near-global ocean simulation</a><a id="Near-global-ocean-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Near-global-ocean-simulation" title="Permalink"></a></h1><p>This example sets up and runs a near-global ocean simulation using the Oceananigans.jl and ClimaOcean.jl. The simulation covers latitudes from 75°S to 75°N, with a horizontal resolution of 1/4 degree and 40 vertical levels.</p><p>The simulation&#39;s results are visualized with the CairoMakie.jl package.</p><h2 id="Initial-setup-with-package-imports"><a class="docs-heading-anchor" href="#Initial-setup-with-package-imports">Initial setup with package imports</a><a id="Initial-setup-with-package-imports-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-setup-with-package-imports" title="Permalink"></a></h2><p>We begin by importing the necessary Julia packages for visualization (CairoMakie), ocean modeling (Oceananigans, ClimaOcean), and handling dates and times (CFTime, Dates). These packages provide the foundational tools for setting up the simulation environment, including grid setup, physical processes modeling, and data visualization.</p><pre><code class="language-julia hljs">using ClimaOcean
using ClimaOcean.ECCO
using Oceananigans
using Oceananigans.Units
using CairoMakie
using CFTime
using Dates
using Printf</code></pre><h3 id="Grid-configuration"><a class="docs-heading-anchor" href="#Grid-configuration">Grid configuration</a><a id="Grid-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-configuration" title="Permalink"></a></h3><p>We define a global grid with a horizontal resolution of 1/4 degree and 40 vertical levels. The grid is a <code>LatitudeLongitudeGrid</code> spanning latitudes from 75°S to 75°N. We use an exponential vertical spacing to better resolve the upper-ocean layers. The total depth of the domain is set to 6000 meters. Finally, we specify the architecture for the simulation, which in this case is a GPU.</p><pre><code class="language-julia hljs">arch = GPU()
Nx = 1440
Ny = 600
Nz = 40

depth = 6000meters
z_faces = exponential_z_faces(; Nz, depth)

grid = LatitudeLongitudeGrid(arch;
                             size = (Nx, Ny, Nz),
                             halo = (7, 7, 7),
                             z = z_faces,
                             latitude  = (-75, 75),
                             longitude = (0, 360))</code></pre><pre><code class="nohighlight hljs">1440×600×40 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on CUDAGPU with 7×7×7 halo and with precomputed metrics
├── longitude: Periodic λ ∈ [0.0, 360.0)   regularly spaced with Δλ=0.25
├── latitude:  Bounded  φ ∈ [-75.0, 75.0]  regularly spaced with Δφ=0.25
└── z:         Bounded  z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=8.0258, max(Δz)=645.588</code></pre><h3 id="Bathymetry-and-immersed-boundary"><a class="docs-heading-anchor" href="#Bathymetry-and-immersed-boundary">Bathymetry and immersed boundary</a><a id="Bathymetry-and-immersed-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Bathymetry-and-immersed-boundary" title="Permalink"></a></h3><p>We use <code>regrid_bathymetry</code> to derive the bottom height from ETOPO1 data. To smooth the interpolated data we use 5 interpolation passes. We also fill in</p><ul><li>all the minor enclosed basins except the 3 largest <code>major_basins</code>, as well as</li><li>regions that are shallower than <code>minimum_depth</code>.</li></ul><pre><code class="language-julia hljs">bottom_height = regrid_bathymetry(grid;
                                  minimum_depth = 10meters,
                                  interpolation_passes = 5,
                                  major_basins = 3)

grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom_height); active_cells_map=true)</code></pre><pre><code class="nohighlight hljs">1440×600×40 ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on CUDAGPU with 7×7×7 halo:
├── immersed_boundary: GridFittedBottom(mean(z)=-2513.76, min(z)=-6000.0, max(z)=0.0)
├── underlying_grid: 1440×600×40 LatitudeLongitudeGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on CUDAGPU with 7×7×7 halo and with precomputed metrics
├── longitude: Periodic λ ∈ [0.0, 360.0)   regularly spaced with Δλ=0.25
├── latitude:  Bounded  φ ∈ [-75.0, 75.0]  regularly spaced with Δφ=0.25
└── z:         Bounded  z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=8.0258, max(Δz)=645.588</code></pre><p>Let&#39;s see what the bathymetry looks like:</p><pre><code class="language-julia hljs">h = grid.immersed_boundary.bottom_height

fig, ax, hm = heatmap(h, colormap=:deep, colorrange=(-depth, 0))
Colorbar(fig[0, 1], hm, label=&quot;Bottom height (m)&quot;, vertical=false)
save(&quot;bathymetry.png&quot;, fig)</code></pre><p><img src="../bathymetry.png" alt/></p><h3 id="Ocean-model-configuration"><a class="docs-heading-anchor" href="#Ocean-model-configuration">Ocean model configuration</a><a id="Ocean-model-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Ocean-model-configuration" title="Permalink"></a></h3><p>We build our ocean model using <code>ocean_simulation</code>,</p><pre><code class="language-julia hljs">ocean = ocean_simulation(grid)</code></pre><pre><code class="nohighlight hljs">Simulation of HydrostaticFreeSurfaceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)
├── Next time step: 2.254 hours
├── Elapsed wall time: 0 seconds
├── Wall time per iteration: NaN days
├── Stop time: Inf days
├── Stop iteration: Inf
├── Wall time limit: Inf
├── Minimum relative step: 0.0
├── Callbacks: OrderedDict with 4 entries:
│   ├── stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)
│   ├── stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)
│   ├── wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)
│   └── nan_checker =&gt; Callback of NaNChecker for u on IterationInterval(100)
├── Output writers: OrderedDict with no entries
└── Diagnostics: OrderedDict with no entries</code></pre><p>which uses the default <code>ocean.model</code>,</p><pre><code class="language-julia hljs">ocean.model</code></pre><pre><code class="nohighlight hljs">HydrostaticFreeSurfaceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)
├── grid: 1440×600×40 ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Bounded, Oceananigans.Grids.Bounded} on CUDAGPU with 7×7×7 halo
├── timestepper: QuasiAdamsBashforth2TimeStepper
├── tracers: (T, S, e)
├── closure: CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization}
├── buoyancy: SeawaterBuoyancy with g=9.80665 and BoussinesqEquationOfState{Float64} with ĝ = NegativeZDirection()
├── free surface: Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitFreeSurfaces.SplitExplicitFreeSurface with gravitational acceleration 9.80665 m s⁻²
│   └── substepping: FixedTimeStepSize(20.254 seconds)
├── advection scheme: 
│   ├── momentum: Vector Invariant, Dimension-by-dimension reconstruction
│   ├── T: FluxFormAdvection(x=WENO(order=7), y=WENO(order=7), z=Centered(order=2))
│   ├── S: FluxFormAdvection(x=WENO(order=7), y=WENO(order=7), z=Centered(order=2))
│   └── e: Nothing
└── coriolis: Oceananigans.Coriolis.HydrostaticSphericalCoriolis{Oceananigans.Advection.EnstrophyConserving{Float64}, Float64}</code></pre><p>We initialize the ocean model with ECCO4 temperature and salinity for January 1, 1992.</p><pre><code class="language-julia hljs">set!(ocean.model, T=ECCOMetadatum(:temperature),
                  S=ECCOMetadatum(:salinity))</code></pre><h3 id="Prescribed-atmosphere-and-radiation"><a class="docs-heading-anchor" href="#Prescribed-atmosphere-and-radiation">Prescribed atmosphere and radiation</a><a id="Prescribed-atmosphere-and-radiation-1"></a><a class="docs-heading-anchor-permalink" href="#Prescribed-atmosphere-and-radiation" title="Permalink"></a></h3><p>Next we build a prescribed atmosphere state and radiation model, which will drive the ocean simulation. We use the default <code>Radiation</code> model,</p><p>The radiation model specifies an ocean albedo emissivity to compute the net radiative fluxes. The default ocean albedo is based on Payne (1982) and depends on cloud cover (calculated from the ratio of maximum possible incident solar radiation to actual incident solar radiation) and latitude. The ocean emissivity is set to 0.97.</p><pre><code class="language-julia hljs">radiation = Radiation(arch)</code></pre><pre><code class="nohighlight hljs">Radiation{Float64}:
├── stefan_boltzmann_constant: 5.67e-8
├── emission: SurfaceProperties
│   ├── ocean: 0.97
│   └── sea_ice: 0.97
└── reflection: SurfaceProperties
    ├── ocean: 0.05
    └── sea_ice: 0.7</code></pre><p>The atmospheric data is prescribed using the JRA55 dataset. The JRA55 dataset provides atmospheric data such as temperature, humidity, and winds to calculate turbulent fluxes using bulk formulae, see <a href="@ref"><code>CrossRealmFluxes</code></a>. The number of snapshots that are loaded into memory is determined by the <code>backend</code>. Here, we load 41 snapshots at a time into memory.</p><pre><code class="language-julia hljs">atmosphere = JRA55PrescribedAtmosphere(arch; backend=JRA55NetCDFBackend(41))</code></pre><pre><code class="nohighlight hljs">640×320×1×2920 PrescribedAtmosphere{Float32} on Oceananigans.Grids.LatitudeLongitudeGrid:
├── times: 2920-element StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
├── surface_layer_height: 10.0
└── boundary_layer_height: 512.0</code></pre><h2 id="The-coupled-simulation"><a class="docs-heading-anchor" href="#The-coupled-simulation">The coupled simulation</a><a id="The-coupled-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#The-coupled-simulation" title="Permalink"></a></h2><p>Next we assemble the ocean, atmosphere, and radiation into a coupled model,</p><pre><code class="language-julia hljs">coupled_model = OceanSeaIceModel(ocean; atmosphere, radiation)</code></pre><pre><code class="nohighlight hljs">OceanSeaIceModel{GPU}(time = 0 seconds, iteration = 0)
├── ocean: HydrostaticFreeSurfaceModel{GPU, ImmersedBoundaryGrid}(time = 0 seconds, iteration = 0)
├── atmosphere: 640×320×1×2920 PrescribedAtmosphere{Float32}
├── sea_ice: FreezingLimitedOceanTemperature{ClimaSeaIce.SeaIceThermodynamics.LinearLiquidus{Float64}}
└── interface: ComponentInterfaces</code></pre><p>We then create a coupled simulation. We start with a small-ish time step of 90 seconds. We run the simulation for 10 days with this small-ish time step.</p><pre><code class="language-julia hljs">simulation = Simulation(coupled_model; Δt=90, stop_time=10days)</code></pre><pre><code class="nohighlight hljs">Simulation of OceanSeaIceModel{GPU}(time = 0 seconds, iteration = 0)
├── Next time step: 1.500 minutes
├── Elapsed wall time: 0 seconds
├── Wall time per iteration: NaN days
├── Stop time: 10 days
├── Stop iteration: Inf
├── Wall time limit: Inf
├── Minimum relative step: 0.0
├── Callbacks: OrderedDict with 4 entries:
│   ├── stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)
│   ├── stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)
│   ├── wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)
│   └── nan_checker =&gt; Callback of NaNChecker for u_ocean on IterationInterval(100)
├── Output writers: OrderedDict with no entries
└── Diagnostics: OrderedDict with no entries</code></pre><p>We define a callback function to monitor the simulation&#39;s progress,</p><pre><code class="language-julia hljs">wall_time = Ref(time_ns())

function progress(sim)
    ocean = sim.model.ocean
    u, v, w = ocean.model.velocities
    T = ocean.model.tracers.T

    Tmax = maximum(interior(T))
    Tmin = minimum(interior(T))

    umax = (maximum(abs, interior(u)),
            maximum(abs, interior(v)),
            maximum(abs, interior(w)))

    step_time = 1e-9 * (time_ns() - wall_time[])

    msg = @sprintf(&quot;Iter: %d, time: %s, Δt: %s&quot;, iteration(sim), prettytime(sim), prettytime(sim.Δt))
    msg *= @sprintf(&quot;, max|u|: (%.2e, %.2e, %.2e) m s⁻¹, extrema(T): (%.2f, %.2f) ᵒC, wall time: %s&quot;,
                    umax..., Tmax, Tmin, prettytime(step_time))

    @info msg

    wall_time[] = time_ns()
end

simulation.callbacks[:progress] = Callback(progress, TimeInterval(5days))</code></pre><pre><code class="nohighlight hljs">Callback of progress on TimeInterval(5 days)</code></pre><h3 id="Set-up-output-writers"><a class="docs-heading-anchor" href="#Set-up-output-writers">Set up output writers</a><a id="Set-up-output-writers-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-output-writers" title="Permalink"></a></h3><p>We define output writers to save the simulation data at regular intervals. In this case, we save the surface fluxes and surface fields at a relatively high frequency (every day). The <code>indices</code> keyword argument allows us to save only a slice of the three dimensional variable. Below, we use <code>indices</code> to save only the values of the variables at the surface, which corresponds to <code>k = grid.Nz</code></p><pre><code class="language-julia hljs">outputs = merge(ocean.model.tracers, ocean.model.velocities)
ocean.output_writers[:surface] = JLD2Writer(ocean.model, outputs;
                                            schedule = TimeInterval(1days),
                                            filename = &quot;near_global_surface_fields&quot;,
                                            indices = (:, :, grid.Nz),
                                            with_halos = true,
                                            overwrite_existing = true,
                                            array_type = Array{Float32})</code></pre><pre><code class="nohighlight hljs">JLD2Writer scheduled on TimeInterval(1 day):
├── filepath: near_global_surface_fields.jld2
├── 6 outputs: (T, S, e, u, v, w)
├── array type: Array{Float32}
├── including: [:grid, :coriolis, :buoyancy, :closure]
├── file_splitting: NoFileSplitting
└── file size: 13.8 MiB</code></pre><h3 id="Spinning-up-the-simulation"><a class="docs-heading-anchor" href="#Spinning-up-the-simulation">Spinning up the simulation</a><a id="Spinning-up-the-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Spinning-up-the-simulation" title="Permalink"></a></h3><p>We spin up the simulation with a small-ish time-step to resolve the &quot;initialization shock&quot; associated with starting from ECCO2 initial conditions that are both interpolated and also satisfy a different dynamical balance than our simulation.</p><pre><code class="language-julia hljs">run!(simulation)</code></pre><pre><code class="nohighlight hljs">[ Info: Initializing simulation...
[ Info: Iter: 0, time: 0 seconds, Δt: 1.500 minutes, max|u|: (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹, extrema(T): (31.53, -1.88) ᵒC, wall time: 49.811 seconds
[ Info:     ... simulation initialization complete (44.080 seconds)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (14.558 seconds).
[ Info: Iter: 4800, time: 5 days, Δt: 1.500 minutes, max|u|: (1.59e+00, 1.86e+00, 2.38e-02) m s⁻¹, extrema(T): (33.54, -1.88) ᵒC, wall time: 19.932 minutes
[ Info: Simulation is stopping after running for 40.461 minutes.
[ Info: Simulation time 10 days equals or exceeds stop time 10 days.
[ Info: Iter: 9600, time: 10 days, Δt: 1.500 minutes, max|u|: (1.85e+00, 1.90e+00, 1.26e-02) m s⁻¹, extrema(T): (35.76, -1.88) ᵒC, wall time: 19.855 minutes
</code></pre><h3 id="Running-the-simulation-for-real"><a class="docs-heading-anchor" href="#Running-the-simulation-for-real">Running the simulation for real</a><a id="Running-the-simulation-for-real-1"></a><a class="docs-heading-anchor-permalink" href="#Running-the-simulation-for-real" title="Permalink"></a></h3><p>After the initial spin up of 10 days, we can increase the time-step and run for longer.</p><pre><code class="language-julia hljs">simulation.stop_time = 60days
simulation.Δt = 10minutes
run!(simulation)</code></pre><pre><code class="nohighlight hljs">[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (8.221 ms)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (7.884 seconds).
[ Info: Iter: 10320, time: 15 days, Δt: 10 minutes, max|u|: (1.95e+00, 1.97e+00, 1.01e-02) m s⁻¹, extrema(T): (37.91, -1.88) ᵒC, wall time: 3.209 minutes
[ Info: Iter: 11040, time: 20 days, Δt: 10 minutes, max|u|: (1.64e+00, 1.85e+00, 1.71e-02) m s⁻¹, extrema(T): (39.37, -1.88) ᵒC, wall time: 3.211 minutes
[ Info: Iter: 11760, time: 25 days, Δt: 10 minutes, max|u|: (1.91e+00, 2.21e+00, 1.76e-02) m s⁻¹, extrema(T): (41.34, -1.89) ᵒC, wall time: 3.207 minutes
[ Info: Iter: 12480, time: 30 days, Δt: 10 minutes, max|u|: (2.52e+00, 2.18e+00, 2.03e-02) m s⁻¹, extrema(T): (43.35, -1.93) ᵒC, wall time: 3.212 minutes
[ Info: Iter: 13200, time: 35 days, Δt: 10 minutes, max|u|: (2.30e+00, 2.47e+00, 2.40e-02) m s⁻¹, extrema(T): (43.83, -1.94) ᵒC, wall time: 3.214 minutes
[ Info: Iter: 13920, time: 40 days, Δt: 10 minutes, max|u|: (1.96e+00, 2.28e+00, 2.44e-02) m s⁻¹, extrema(T): (44.99, -1.95) ᵒC, wall time: 3.282 minutes
[ Info: Iter: 14640, time: 45 days, Δt: 10 minutes, max|u|: (2.22e+00, 2.10e+00, 2.91e-02) m s⁻¹, extrema(T): (46.74, -1.98) ᵒC, wall time: 3.211 minutes
[ Info: Iter: 15360, time: 50 days, Δt: 10 minutes, max|u|: (2.32e+00, 2.48e+00, 2.28e-02) m s⁻¹, extrema(T): (47.53, -2.03) ᵒC, wall time: 3.253 minutes
[ Info: Iter: 16080, time: 55 days, Δt: 10 minutes, max|u|: (2.78e+00, 3.15e+00, 2.11e-02) m s⁻¹, extrema(T): (48.07, -1.88) ᵒC, wall time: 3.233 minutes
[ Info: Simulation is stopping after running for 32.227 minutes.
[ Info: Simulation time 60 days equals or exceeds stop time 60 days.
[ Info: Iter: 16800, time: 60 days, Δt: 10 minutes, max|u|: (1.97e+00, 1.71e+00, 1.68e-02) m s⁻¹, extrema(T): (48.07, -1.88) ᵒC, wall time: 3.233 minutes
</code></pre><h2 id="A-pretty-movie"><a class="docs-heading-anchor" href="#A-pretty-movie">A pretty movie</a><a id="A-pretty-movie-1"></a><a class="docs-heading-anchor-permalink" href="#A-pretty-movie" title="Permalink"></a></h2><p>It&#39;s time to make a pretty movie of the simulation. First we load the output we&#39;ve been saving on disk and plot the final snapshot:</p><pre><code class="language-julia hljs">u = FieldTimeSeries(&quot;near_global_surface_fields.jld2&quot;, &quot;u&quot;; backend = OnDisk())
v = FieldTimeSeries(&quot;near_global_surface_fields.jld2&quot;, &quot;v&quot;; backend = OnDisk())
T = FieldTimeSeries(&quot;near_global_surface_fields.jld2&quot;, &quot;T&quot;; backend = OnDisk())
e = FieldTimeSeries(&quot;near_global_surface_fields.jld2&quot;, &quot;e&quot;; backend = OnDisk())

times = u.times
Nt = length(times)

n = Observable(Nt)

land = interior(T.grid.immersed_boundary.bottom_height) .&gt;= 0

Tn = @lift begin
    Tn = interior(T[$n])
    Tn[land] .= NaN
    view(Tn, :, :, 1)
end

en = @lift begin
    en = interior(e[$n])
    en[land] .= NaN
    view(en, :, :, 1)
end

un = Field{Face, Center, Nothing}(u.grid)
vn = Field{Center, Face, Nothing}(v.grid)

s = @at (Center, Center, Nothing) sqrt(un^2 + vn^2) # compute √(u²+v²) and interpolate back to Center, Center
s = Field(s)

sn = @lift begin
    parent(un) .= parent(u[$n])
    parent(vn) .= parent(v[$n])
    compute!(s)
    sn = interior(s)
    sn[land] .= NaN
    view(sn, :, :, 1)
end

title = @lift string(&quot;Near-global 1/4 degree ocean simulation after &quot;,
                     prettytime(times[$n] - times[1]))

λ, φ, _ = nodes(T) # T, e, and s all live on the same grid locations

fig = Figure(size = (1000, 1500))

axs = Axis(fig[1, 1], xlabel=&quot;Longitude (deg)&quot;, ylabel=&quot;Latitude (deg)&quot;)
axT = Axis(fig[2, 1], xlabel=&quot;Longitude (deg)&quot;, ylabel=&quot;Latitude (deg)&quot;)
axe = Axis(fig[3, 1], xlabel=&quot;Longitude (deg)&quot;, ylabel=&quot;Latitude (deg)&quot;)

hm = heatmap!(axs, λ, φ, sn, colorrange = (0, 0.5), colormap = :deep, nan_color=:lightgray)
Colorbar(fig[1, 2], hm, label = &quot;Surface Speed (m s⁻¹)&quot;)

hm = heatmap!(axT, λ, φ, Tn, colorrange = (-1, 30), colormap = :magma, nan_color=:lightgray)
Colorbar(fig[2, 2], hm, label = &quot;Surface Temperature (ᵒC)&quot;)

hm = heatmap!(axe, λ, φ, en, colorrange = (0, 1e-3), colormap = :solar, nan_color=:lightgray)
Colorbar(fig[3, 2], hm, label = &quot;Turbulent Kinetic Energy (m² s⁻²)&quot;)

Label(fig[0, :], title)

save(&quot;snapshot.png&quot;, fig)</code></pre><p><img src="../snapshot.png" alt/></p><p>And now we make a movie:</p><pre><code class="language-julia hljs">record(fig, &quot;near_global_ocean_surface.mp4&quot;, 1:Nt, framerate = 8) do nn
    n[] = nn
end</code></pre><p><video src="../near_global_ocean_surface.mp4" controls="true" title><a href="../near_global_ocean_surface.mp4"></a></video></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../one_degree_simulation/">« One-degree Ocean simulation</a><a class="docs-footer-nextpage" href="../../library/outline/">Contents »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.0 on <span class="colophon-date" title="Saturday 10 May 2025 16:27">Saturday 10 May 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
